package network

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"encoding/json"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/date"
	"github.com/Azure/go-autorest/autorest/to"
	"github.com/Azure/go-autorest/tracing"
	"net/http"
)

// The package's fully qualified name.
const fqdn = "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2022-01-01/network"

// BasicActiveBaseSecurityAdminRule network base admin rule.
type BasicActiveBaseSecurityAdminRule interface {
	AsActiveSecurityAdminRule() (*ActiveSecurityAdminRule, bool)
	AsActiveDefaultSecurityAdminRule() (*ActiveDefaultSecurityAdminRule, bool)
	AsActiveBaseSecurityAdminRule() (*ActiveBaseSecurityAdminRule, bool)
}

// ActiveBaseSecurityAdminRule network base admin rule.
type ActiveBaseSecurityAdminRule struct {
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// CommitTime - Deployment time string.
	CommitTime *date.Time `json:"commitTime,omitempty"`
	// Region - Deployment region.
	Region *string `json:"region,omitempty"`
	// ConfigurationDescription - A description of the security admin configuration.
	ConfigurationDescription *string `json:"configurationDescription,omitempty"`
	// RuleCollectionDescription - A description of the rule collection.
	RuleCollectionDescription *string `json:"ruleCollectionDescription,omitempty"`
	// RuleCollectionAppliesToGroups - Groups for rule collection
	RuleCollectionAppliesToGroups *[]ManagerSecurityGroupItem `json:"ruleCollectionAppliesToGroups,omitempty"`
	// RuleGroups - Effective configuration groups.
	RuleGroups *[]ConfigurationGroup `json:"ruleGroups,omitempty"`
	// Kind - Possible values include: 'KindActiveBaseSecurityAdminRule', 'KindCustom', 'KindDefault'
	Kind Kind `json:"kind,omitempty"`
}

func unmarshalBasicActiveBaseSecurityAdminRule(body []byte) (BasicActiveBaseSecurityAdminRule, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["kind"] {
	case string(KindCustom):
		var asar ActiveSecurityAdminRule
		err := json.Unmarshal(body, &asar)
		return asar, err
	case string(KindDefault):
		var adsar ActiveDefaultSecurityAdminRule
		err := json.Unmarshal(body, &adsar)
		return adsar, err
	default:
		var absar ActiveBaseSecurityAdminRule
		err := json.Unmarshal(body, &absar)
		return absar, err
	}
}
func unmarshalBasicActiveBaseSecurityAdminRuleArray(body []byte) ([]BasicActiveBaseSecurityAdminRule, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	absarArray := make([]BasicActiveBaseSecurityAdminRule, len(rawMessages))

	for index, rawMessage := range rawMessages {
		absar, err := unmarshalBasicActiveBaseSecurityAdminRule(*rawMessage)
		if err != nil {
			return nil, err
		}
		absarArray[index] = absar
	}
	return absarArray, nil
}

// MarshalJSON is the custom marshaler for ActiveBaseSecurityAdminRule.
func (absar ActiveBaseSecurityAdminRule) MarshalJSON() ([]byte, error) {
	absar.Kind = KindActiveBaseSecurityAdminRule
	objectMap := make(map[string]interface{})
	if absar.ID != nil {
		objectMap["id"] = absar.ID
	}
	if absar.CommitTime != nil {
		objectMap["commitTime"] = absar.CommitTime
	}
	if absar.Region != nil {
		objectMap["region"] = absar.Region
	}
	if absar.ConfigurationDescription != nil {
		objectMap["configurationDescription"] = absar.ConfigurationDescription
	}
	if absar.RuleCollectionDescription != nil {
		objectMap["ruleCollectionDescription"] = absar.RuleCollectionDescription
	}
	if absar.RuleCollectionAppliesToGroups != nil {
		objectMap["ruleCollectionAppliesToGroups"] = absar.RuleCollectionAppliesToGroups
	}
	if absar.RuleGroups != nil {
		objectMap["ruleGroups"] = absar.RuleGroups
	}
	if absar.Kind != "" {
		objectMap["kind"] = absar.Kind
	}
	return json.Marshal(objectMap)
}

// AsActiveSecurityAdminRule is the BasicActiveBaseSecurityAdminRule implementation for ActiveBaseSecurityAdminRule.
func (absar ActiveBaseSecurityAdminRule) AsActiveSecurityAdminRule() (*ActiveSecurityAdminRule, bool) {
	return nil, false
}

// AsActiveDefaultSecurityAdminRule is the BasicActiveBaseSecurityAdminRule implementation for ActiveBaseSecurityAdminRule.
func (absar ActiveBaseSecurityAdminRule) AsActiveDefaultSecurityAdminRule() (*ActiveDefaultSecurityAdminRule, bool) {
	return nil, false
}

// AsActiveBaseSecurityAdminRule is the BasicActiveBaseSecurityAdminRule implementation for ActiveBaseSecurityAdminRule.
func (absar ActiveBaseSecurityAdminRule) AsActiveBaseSecurityAdminRule() (*ActiveBaseSecurityAdminRule, bool) {
	return &absar, true
}

// AsBasicActiveBaseSecurityAdminRule is the BasicActiveBaseSecurityAdminRule implementation for ActiveBaseSecurityAdminRule.
func (absar ActiveBaseSecurityAdminRule) AsBasicActiveBaseSecurityAdminRule() (BasicActiveBaseSecurityAdminRule, bool) {
	return &absar, true
}

// ActiveConfigurationParameter effective Virtual Networks Parameter.
type ActiveConfigurationParameter struct {
	// Regions - List of regions.
	Regions *[]string `json:"regions,omitempty"`
	// SkipToken - When present, the value can be passed to a subsequent query call (together with the same query and scopes used in the current request) to retrieve the next page of data.
	SkipToken *string `json:"skipToken,omitempty"`
}

// ActiveConnectivityConfiguration active connectivity configuration.
type ActiveConnectivityConfiguration struct {
	// CommitTime - Deployment time string.
	CommitTime *date.Time `json:"commitTime,omitempty"`
	// Region - Deployment region.
	Region *string `json:"region,omitempty"`
	// ID - Connectivity configuration ID.
	ID *string `json:"id,omitempty"`
	// ConnectivityConfigurationProperties - Properties of a network manager connectivity configuration
	*ConnectivityConfigurationProperties `json:"properties,omitempty"`
	// ConfigurationGroups - Effective configuration groups.
	ConfigurationGroups *[]ConfigurationGroup `json:"configurationGroups,omitempty"`
}

// MarshalJSON is the custom marshaler for ActiveConnectivityConfiguration.
func (acc ActiveConnectivityConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if acc.CommitTime != nil {
		objectMap["commitTime"] = acc.CommitTime
	}
	if acc.Region != nil {
		objectMap["region"] = acc.Region
	}
	if acc.ID != nil {
		objectMap["id"] = acc.ID
	}
	if acc.ConnectivityConfigurationProperties != nil {
		objectMap["properties"] = acc.ConnectivityConfigurationProperties
	}
	if acc.ConfigurationGroups != nil {
		objectMap["configurationGroups"] = acc.ConfigurationGroups
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ActiveConnectivityConfiguration struct.
func (acc *ActiveConnectivityConfiguration) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "commitTime":
			if v != nil {
				var commitTime date.Time
				err = json.Unmarshal(*v, &commitTime)
				if err != nil {
					return err
				}
				acc.CommitTime = &commitTime
			}
		case "region":
			if v != nil {
				var region string
				err = json.Unmarshal(*v, &region)
				if err != nil {
					return err
				}
				acc.Region = &region
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				acc.ID = &ID
			}
		case "properties":
			if v != nil {
				var connectivityConfigurationProperties ConnectivityConfigurationProperties
				err = json.Unmarshal(*v, &connectivityConfigurationProperties)
				if err != nil {
					return err
				}
				acc.ConnectivityConfigurationProperties = &connectivityConfigurationProperties
			}
		case "configurationGroups":
			if v != nil {
				var configurationGroups []ConfigurationGroup
				err = json.Unmarshal(*v, &configurationGroups)
				if err != nil {
					return err
				}
				acc.ConfigurationGroups = &configurationGroups
			}
		}
	}

	return nil
}

// ActiveConnectivityConfigurationsListResult result of the request to list active connectivity
// configurations. It contains a list of active connectivity configurations and a skiptoken to get the next
// set of results.
type ActiveConnectivityConfigurationsListResult struct {
	autorest.Response `json:"-"`
	// Value - Gets a page of active connectivity configurations.
	Value *[]ActiveConnectivityConfiguration `json:"value,omitempty"`
	// SkipToken - When present, the value can be passed to a subsequent query call (together with the same query and scopes used in the current request) to retrieve the next page of data.
	SkipToken *string `json:"skipToken,omitempty"`
}

// ActiveDefaultSecurityAdminRule network default admin rule.
type ActiveDefaultSecurityAdminRule struct {
	// DefaultAdminPropertiesFormat - Indicates the properties of the default security admin rule
	*DefaultAdminPropertiesFormat `json:"properties,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// CommitTime - Deployment time string.
	CommitTime *date.Time `json:"commitTime,omitempty"`
	// Region - Deployment region.
	Region *string `json:"region,omitempty"`
	// ConfigurationDescription - A description of the security admin configuration.
	ConfigurationDescription *string `json:"configurationDescription,omitempty"`
	// RuleCollectionDescription - A description of the rule collection.
	RuleCollectionDescription *string `json:"ruleCollectionDescription,omitempty"`
	// RuleCollectionAppliesToGroups - Groups for rule collection
	RuleCollectionAppliesToGroups *[]ManagerSecurityGroupItem `json:"ruleCollectionAppliesToGroups,omitempty"`
	// RuleGroups - Effective configuration groups.
	RuleGroups *[]ConfigurationGroup `json:"ruleGroups,omitempty"`
	// Kind - Possible values include: 'KindActiveBaseSecurityAdminRule', 'KindCustom', 'KindDefault'
	Kind Kind `json:"kind,omitempty"`
}

// MarshalJSON is the custom marshaler for ActiveDefaultSecurityAdminRule.
func (adsar ActiveDefaultSecurityAdminRule) MarshalJSON() ([]byte, error) {
	adsar.Kind = KindDefault
	objectMap := make(map[string]interface{})
	if adsar.DefaultAdminPropertiesFormat != nil {
		objectMap["properties"] = adsar.DefaultAdminPropertiesFormat
	}
	if adsar.ID != nil {
		objectMap["id"] = adsar.ID
	}
	if adsar.CommitTime != nil {
		objectMap["commitTime"] = adsar.CommitTime
	}
	if adsar.Region != nil {
		objectMap["region"] = adsar.Region
	}
	if adsar.ConfigurationDescription != nil {
		objectMap["configurationDescription"] = adsar.ConfigurationDescription
	}
	if adsar.RuleCollectionDescription != nil {
		objectMap["ruleCollectionDescription"] = adsar.RuleCollectionDescription
	}
	if adsar.RuleCollectionAppliesToGroups != nil {
		objectMap["ruleCollectionAppliesToGroups"] = adsar.RuleCollectionAppliesToGroups
	}
	if adsar.RuleGroups != nil {
		objectMap["ruleGroups"] = adsar.RuleGroups
	}
	if adsar.Kind != "" {
		objectMap["kind"] = adsar.Kind
	}
	return json.Marshal(objectMap)
}

// AsActiveSecurityAdminRule is the BasicActiveBaseSecurityAdminRule implementation for ActiveDefaultSecurityAdminRule.
func (adsar ActiveDefaultSecurityAdminRule) AsActiveSecurityAdminRule() (*ActiveSecurityAdminRule, bool) {
	return nil, false
}

// AsActiveDefaultSecurityAdminRule is the BasicActiveBaseSecurityAdminRule implementation for ActiveDefaultSecurityAdminRule.
func (adsar ActiveDefaultSecurityAdminRule) AsActiveDefaultSecurityAdminRule() (*ActiveDefaultSecurityAdminRule, bool) {
	return &adsar, true
}

// AsActiveBaseSecurityAdminRule is the BasicActiveBaseSecurityAdminRule implementation for ActiveDefaultSecurityAdminRule.
func (adsar ActiveDefaultSecurityAdminRule) AsActiveBaseSecurityAdminRule() (*ActiveBaseSecurityAdminRule, bool) {
	return nil, false
}

// AsBasicActiveBaseSecurityAdminRule is the BasicActiveBaseSecurityAdminRule implementation for ActiveDefaultSecurityAdminRule.
func (adsar ActiveDefaultSecurityAdminRule) AsBasicActiveBaseSecurityAdminRule() (BasicActiveBaseSecurityAdminRule, bool) {
	return &adsar, true
}

// UnmarshalJSON is the custom unmarshaler for ActiveDefaultSecurityAdminRule struct.
func (adsar *ActiveDefaultSecurityAdminRule) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var defaultAdminPropertiesFormat DefaultAdminPropertiesFormat
				err = json.Unmarshal(*v, &defaultAdminPropertiesFormat)
				if err != nil {
					return err
				}
				adsar.DefaultAdminPropertiesFormat = &defaultAdminPropertiesFormat
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				adsar.ID = &ID
			}
		case "commitTime":
			if v != nil {
				var commitTime date.Time
				err = json.Unmarshal(*v, &commitTime)
				if err != nil {
					return err
				}
				adsar.CommitTime = &commitTime
			}
		case "region":
			if v != nil {
				var region string
				err = json.Unmarshal(*v, &region)
				if err != nil {
					return err
				}
				adsar.Region = &region
			}
		case "configurationDescription":
			if v != nil {
				var configurationDescription string
				err = json.Unmarshal(*v, &configurationDescription)
				if err != nil {
					return err
				}
				adsar.ConfigurationDescription = &configurationDescription
			}
		case "ruleCollectionDescription":
			if v != nil {
				var ruleCollectionDescription string
				err = json.Unmarshal(*v, &ruleCollectionDescription)
				if err != nil {
					return err
				}
				adsar.RuleCollectionDescription = &ruleCollectionDescription
			}
		case "ruleCollectionAppliesToGroups":
			if v != nil {
				var ruleCollectionAppliesToGroups []ManagerSecurityGroupItem
				err = json.Unmarshal(*v, &ruleCollectionAppliesToGroups)
				if err != nil {
					return err
				}
				adsar.RuleCollectionAppliesToGroups = &ruleCollectionAppliesToGroups
			}
		case "ruleGroups":
			if v != nil {
				var ruleGroups []ConfigurationGroup
				err = json.Unmarshal(*v, &ruleGroups)
				if err != nil {
					return err
				}
				adsar.RuleGroups = &ruleGroups
			}
		case "kind":
			if v != nil {
				var kind Kind
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				adsar.Kind = kind
			}
		}
	}

	return nil
}

// ActiveSecurityAdminRule network admin rule.
type ActiveSecurityAdminRule struct {
	// AdminPropertiesFormat - Indicates the properties of the security admin rule
	*AdminPropertiesFormat `json:"properties,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// CommitTime - Deployment time string.
	CommitTime *date.Time `json:"commitTime,omitempty"`
	// Region - Deployment region.
	Region *string `json:"region,omitempty"`
	// ConfigurationDescription - A description of the security admin configuration.
	ConfigurationDescription *string `json:"configurationDescription,omitempty"`
	// RuleCollectionDescription - A description of the rule collection.
	RuleCollectionDescription *string `json:"ruleCollectionDescription,omitempty"`
	// RuleCollectionAppliesToGroups - Groups for rule collection
	RuleCollectionAppliesToGroups *[]ManagerSecurityGroupItem `json:"ruleCollectionAppliesToGroups,omitempty"`
	// RuleGroups - Effective configuration groups.
	RuleGroups *[]ConfigurationGroup `json:"ruleGroups,omitempty"`
	// Kind - Possible values include: 'KindActiveBaseSecurityAdminRule', 'KindCustom', 'KindDefault'
	Kind Kind `json:"kind,omitempty"`
}

// MarshalJSON is the custom marshaler for ActiveSecurityAdminRule.
func (asar ActiveSecurityAdminRule) MarshalJSON() ([]byte, error) {
	asar.Kind = KindCustom
	objectMap := make(map[string]interface{})
	if asar.AdminPropertiesFormat != nil {
		objectMap["properties"] = asar.AdminPropertiesFormat
	}
	if asar.ID != nil {
		objectMap["id"] = asar.ID
	}
	if asar.CommitTime != nil {
		objectMap["commitTime"] = asar.CommitTime
	}
	if asar.Region != nil {
		objectMap["region"] = asar.Region
	}
	if asar.ConfigurationDescription != nil {
		objectMap["configurationDescription"] = asar.ConfigurationDescription
	}
	if asar.RuleCollectionDescription != nil {
		objectMap["ruleCollectionDescription"] = asar.RuleCollectionDescription
	}
	if asar.RuleCollectionAppliesToGroups != nil {
		objectMap["ruleCollectionAppliesToGroups"] = asar.RuleCollectionAppliesToGroups
	}
	if asar.RuleGroups != nil {
		objectMap["ruleGroups"] = asar.RuleGroups
	}
	if asar.Kind != "" {
		objectMap["kind"] = asar.Kind
	}
	return json.Marshal(objectMap)
}

// AsActiveSecurityAdminRule is the BasicActiveBaseSecurityAdminRule implementation for ActiveSecurityAdminRule.
func (asar ActiveSecurityAdminRule) AsActiveSecurityAdminRule() (*ActiveSecurityAdminRule, bool) {
	return &asar, true
}

// AsActiveDefaultSecurityAdminRule is the BasicActiveBaseSecurityAdminRule implementation for ActiveSecurityAdminRule.
func (asar ActiveSecurityAdminRule) AsActiveDefaultSecurityAdminRule() (*ActiveDefaultSecurityAdminRule, bool) {
	return nil, false
}

// AsActiveBaseSecurityAdminRule is the BasicActiveBaseSecurityAdminRule implementation for ActiveSecurityAdminRule.
func (asar ActiveSecurityAdminRule) AsActiveBaseSecurityAdminRule() (*ActiveBaseSecurityAdminRule, bool) {
	return nil, false
}

// AsBasicActiveBaseSecurityAdminRule is the BasicActiveBaseSecurityAdminRule implementation for ActiveSecurityAdminRule.
func (asar ActiveSecurityAdminRule) AsBasicActiveBaseSecurityAdminRule() (BasicActiveBaseSecurityAdminRule, bool) {
	return &asar, true
}

// UnmarshalJSON is the custom unmarshaler for ActiveSecurityAdminRule struct.
func (asar *ActiveSecurityAdminRule) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var adminPropertiesFormat AdminPropertiesFormat
				err = json.Unmarshal(*v, &adminPropertiesFormat)
				if err != nil {
					return err
				}
				asar.AdminPropertiesFormat = &adminPropertiesFormat
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				asar.ID = &ID
			}
		case "commitTime":
			if v != nil {
				var commitTime date.Time
				err = json.Unmarshal(*v, &commitTime)
				if err != nil {
					return err
				}
				asar.CommitTime = &commitTime
			}
		case "region":
			if v != nil {
				var region string
				err = json.Unmarshal(*v, &region)
				if err != nil {
					return err
				}
				asar.Region = &region
			}
		case "configurationDescription":
			if v != nil {
				var configurationDescription string
				err = json.Unmarshal(*v, &configurationDescription)
				if err != nil {
					return err
				}
				asar.ConfigurationDescription = &configurationDescription
			}
		case "ruleCollectionDescription":
			if v != nil {
				var ruleCollectionDescription string
				err = json.Unmarshal(*v, &ruleCollectionDescription)
				if err != nil {
					return err
				}
				asar.RuleCollectionDescription = &ruleCollectionDescription
			}
		case "ruleCollectionAppliesToGroups":
			if v != nil {
				var ruleCollectionAppliesToGroups []ManagerSecurityGroupItem
				err = json.Unmarshal(*v, &ruleCollectionAppliesToGroups)
				if err != nil {
					return err
				}
				asar.RuleCollectionAppliesToGroups = &ruleCollectionAppliesToGroups
			}
		case "ruleGroups":
			if v != nil {
				var ruleGroups []ConfigurationGroup
				err = json.Unmarshal(*v, &ruleGroups)
				if err != nil {
					return err
				}
				asar.RuleGroups = &ruleGroups
			}
		case "kind":
			if v != nil {
				var kind Kind
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				asar.Kind = kind
			}
		}
	}

	return nil
}

// ActiveSecurityAdminRulesListResult result of the request to list active security admin rules. It
// contains a list of active security admin rules and a skiptoken to get the next set of results.
type ActiveSecurityAdminRulesListResult struct {
	autorest.Response `json:"-"`
	// Value - Gets a page of active security admin rules.
	Value *[]BasicActiveBaseSecurityAdminRule `json:"value,omitempty"`
	// SkipToken - When present, the value can be passed to a subsequent query call (together with the same query and scopes used in the current request) to retrieve the next page of data.
	SkipToken *string `json:"skipToken,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for ActiveSecurityAdminRulesListResult struct.
func (asarlr *ActiveSecurityAdminRulesListResult) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "value":
			if v != nil {
				value, err := unmarshalBasicActiveBaseSecurityAdminRuleArray(*v)
				if err != nil {
					return err
				}
				asarlr.Value = &value
			}
		case "skipToken":
			if v != nil {
				var skipToken string
				err = json.Unmarshal(*v, &skipToken)
				if err != nil {
					return err
				}
				asarlr.SkipToken = &skipToken
			}
		}
	}

	return nil
}

// AddressPrefixItem address prefix item.
type AddressPrefixItem struct {
	// AddressPrefix - Address prefix.
	AddressPrefix *string `json:"addressPrefix,omitempty"`
	// AddressPrefixType - Address prefix type. Possible values include: 'AddressPrefixTypeIPPrefix', 'AddressPrefixTypeServiceTag'
	AddressPrefixType AddressPrefixType `json:"addressPrefixType,omitempty"`
}

// AdminPropertiesFormat security admin rule resource.
type AdminPropertiesFormat struct {
	// Description - A description for this rule. Restricted to 140 chars.
	Description *string `json:"description,omitempty"`
	// Protocol - Network protocol this rule applies to. Possible values include: 'SecurityConfigurationRuleProtocolTCP', 'SecurityConfigurationRuleProtocolUDP', 'SecurityConfigurationRuleProtocolIcmp', 'SecurityConfigurationRuleProtocolEsp', 'SecurityConfigurationRuleProtocolAny', 'SecurityConfigurationRuleProtocolAh'
	Protocol SecurityConfigurationRuleProtocol `json:"protocol,omitempty"`
	// Sources - The CIDR or source IP ranges.
	Sources *[]AddressPrefixItem `json:"sources,omitempty"`
	// Destinations - The destination address prefixes. CIDR or destination IP ranges.
	Destinations *[]AddressPrefixItem `json:"destinations,omitempty"`
	// SourcePortRanges - The source port ranges.
	SourcePortRanges *[]string `json:"sourcePortRanges,omitempty"`
	// DestinationPortRanges - The destination port ranges.
	DestinationPortRanges *[]string `json:"destinationPortRanges,omitempty"`
	// Access - Indicates the access allowed for this particular rule. Possible values include: 'SecurityConfigurationRuleAccessAllow', 'SecurityConfigurationRuleAccessDeny', 'SecurityConfigurationRuleAccessAlwaysAllow'
	Access SecurityConfigurationRuleAccess `json:"access,omitempty"`
	// Priority - The priority of the rule. The value can be between 1 and 4096. The priority number must be unique for each rule in the collection. The lower the priority number, the higher the priority of the rule.
	Priority *int32 `json:"priority,omitempty"`
	// Direction - Indicates if the traffic matched against the rule in inbound or outbound. Possible values include: 'SecurityConfigurationRuleDirectionInbound', 'SecurityConfigurationRuleDirectionOutbound'
	Direction SecurityConfigurationRuleDirection `json:"direction,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for AdminPropertiesFormat.
func (apf AdminPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if apf.Description != nil {
		objectMap["description"] = apf.Description
	}
	if apf.Protocol != "" {
		objectMap["protocol"] = apf.Protocol
	}
	if apf.Sources != nil {
		objectMap["sources"] = apf.Sources
	}
	if apf.Destinations != nil {
		objectMap["destinations"] = apf.Destinations
	}
	if apf.SourcePortRanges != nil {
		objectMap["sourcePortRanges"] = apf.SourcePortRanges
	}
	if apf.DestinationPortRanges != nil {
		objectMap["destinationPortRanges"] = apf.DestinationPortRanges
	}
	if apf.Access != "" {
		objectMap["access"] = apf.Access
	}
	if apf.Priority != nil {
		objectMap["priority"] = apf.Priority
	}
	if apf.Direction != "" {
		objectMap["direction"] = apf.Direction
	}
	return json.Marshal(objectMap)
}

// AdminRule network admin rule.
type AdminRule struct {
	// AdminPropertiesFormat - Indicates the properties of the security admin rule
	*AdminPropertiesFormat `json:"properties,omitempty"`
	// SystemData - READ-ONLY; The system metadata related to this resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Kind - Possible values include: 'KindBasicBaseAdminRuleKindBaseAdminRule', 'KindBasicBaseAdminRuleKindCustom', 'KindBasicBaseAdminRuleKindDefault'
	Kind KindBasicBaseAdminRule `json:"kind,omitempty"`
}

// MarshalJSON is the custom marshaler for AdminRule.
func (ar AdminRule) MarshalJSON() ([]byte, error) {
	ar.Kind = KindBasicBaseAdminRuleKindCustom
	objectMap := make(map[string]interface{})
	if ar.AdminPropertiesFormat != nil {
		objectMap["properties"] = ar.AdminPropertiesFormat
	}
	if ar.Kind != "" {
		objectMap["kind"] = ar.Kind
	}
	return json.Marshal(objectMap)
}

// AsAdminRule is the BasicBaseAdminRule implementation for AdminRule.
func (ar AdminRule) AsAdminRule() (*AdminRule, bool) {
	return &ar, true
}

// AsDefaultAdminRule is the BasicBaseAdminRule implementation for AdminRule.
func (ar AdminRule) AsDefaultAdminRule() (*DefaultAdminRule, bool) {
	return nil, false
}

// AsBaseAdminRule is the BasicBaseAdminRule implementation for AdminRule.
func (ar AdminRule) AsBaseAdminRule() (*BaseAdminRule, bool) {
	return nil, false
}

// AsBasicBaseAdminRule is the BasicBaseAdminRule implementation for AdminRule.
func (ar AdminRule) AsBasicBaseAdminRule() (BasicBaseAdminRule, bool) {
	return &ar, true
}

// UnmarshalJSON is the custom unmarshaler for AdminRule struct.
func (ar *AdminRule) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var adminPropertiesFormat AdminPropertiesFormat
				err = json.Unmarshal(*v, &adminPropertiesFormat)
				if err != nil {
					return err
				}
				ar.AdminPropertiesFormat = &adminPropertiesFormat
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				ar.SystemData = &systemData
			}
		case "kind":
			if v != nil {
				var kind KindBasicBaseAdminRule
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				ar.Kind = kind
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ar.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ar.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ar.Type = &typeVar
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				ar.Etag = &etag
			}
		}
	}

	return nil
}

// AdminRuleCollection defines the admin rule collection.
type AdminRuleCollection struct {
	autorest.Response `json:"-"`
	// AdminRuleCollectionPropertiesFormat - Indicates the properties for the network manager admin rule collection.
	*AdminRuleCollectionPropertiesFormat `json:"properties,omitempty"`
	// SystemData - READ-ONLY; The system metadata related to this resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
}

// MarshalJSON is the custom marshaler for AdminRuleCollection.
func (arc AdminRuleCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if arc.AdminRuleCollectionPropertiesFormat != nil {
		objectMap["properties"] = arc.AdminRuleCollectionPropertiesFormat
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AdminRuleCollection struct.
func (arc *AdminRuleCollection) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var adminRuleCollectionPropertiesFormat AdminRuleCollectionPropertiesFormat
				err = json.Unmarshal(*v, &adminRuleCollectionPropertiesFormat)
				if err != nil {
					return err
				}
				arc.AdminRuleCollectionPropertiesFormat = &adminRuleCollectionPropertiesFormat
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				arc.SystemData = &systemData
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				arc.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				arc.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				arc.Type = &typeVar
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				arc.Etag = &etag
			}
		}
	}

	return nil
}

// AdminRuleCollectionListResult security admin configuration rule collection list result.
type AdminRuleCollectionListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of network manager security admin configuration rule collections
	Value *[]AdminRuleCollection `json:"value,omitempty"`
	// NextLink - Gets the URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// AdminRuleCollectionListResultIterator provides access to a complete listing of AdminRuleCollection
// values.
type AdminRuleCollectionListResultIterator struct {
	i    int
	page AdminRuleCollectionListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *AdminRuleCollectionListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AdminRuleCollectionListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *AdminRuleCollectionListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter AdminRuleCollectionListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter AdminRuleCollectionListResultIterator) Response() AdminRuleCollectionListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter AdminRuleCollectionListResultIterator) Value() AdminRuleCollection {
	if !iter.page.NotDone() {
		return AdminRuleCollection{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the AdminRuleCollectionListResultIterator type.
func NewAdminRuleCollectionListResultIterator(page AdminRuleCollectionListResultPage) AdminRuleCollectionListResultIterator {
	return AdminRuleCollectionListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (arclr AdminRuleCollectionListResult) IsEmpty() bool {
	return arclr.Value == nil || len(*arclr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (arclr AdminRuleCollectionListResult) hasNextLink() bool {
	return arclr.NextLink != nil && len(*arclr.NextLink) != 0
}

// adminRuleCollectionListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (arclr AdminRuleCollectionListResult) adminRuleCollectionListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !arclr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(arclr.NextLink)))
}

// AdminRuleCollectionListResultPage contains a page of AdminRuleCollection values.
type AdminRuleCollectionListResultPage struct {
	fn    func(context.Context, AdminRuleCollectionListResult) (AdminRuleCollectionListResult, error)
	arclr AdminRuleCollectionListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *AdminRuleCollectionListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AdminRuleCollectionListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.arclr)
		if err != nil {
			return err
		}
		page.arclr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *AdminRuleCollectionListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page AdminRuleCollectionListResultPage) NotDone() bool {
	return !page.arclr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page AdminRuleCollectionListResultPage) Response() AdminRuleCollectionListResult {
	return page.arclr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page AdminRuleCollectionListResultPage) Values() []AdminRuleCollection {
	if page.arclr.IsEmpty() {
		return nil
	}
	return *page.arclr.Value
}

// Creates a new instance of the AdminRuleCollectionListResultPage type.
func NewAdminRuleCollectionListResultPage(cur AdminRuleCollectionListResult, getNextPage func(context.Context, AdminRuleCollectionListResult) (AdminRuleCollectionListResult, error)) AdminRuleCollectionListResultPage {
	return AdminRuleCollectionListResultPage{
		fn:    getNextPage,
		arclr: cur,
	}
}

// AdminRuleCollectionPropertiesFormat defines the admin rule collection properties.
type AdminRuleCollectionPropertiesFormat struct {
	// Description - A description of the admin rule collection.
	Description *string `json:"description,omitempty"`
	// AppliesToGroups - Groups for configuration
	AppliesToGroups *[]ManagerSecurityGroupItem `json:"appliesToGroups,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for AdminRuleCollectionPropertiesFormat.
func (arcpf AdminRuleCollectionPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if arcpf.Description != nil {
		objectMap["description"] = arcpf.Description
	}
	if arcpf.AppliesToGroups != nil {
		objectMap["appliesToGroups"] = arcpf.AppliesToGroups
	}
	return json.Marshal(objectMap)
}

// AdminRuleCollectionsDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type AdminRuleCollectionsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AdminRuleCollectionsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AdminRuleCollectionsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AdminRuleCollectionsDeleteFuture.Result.
func (future *AdminRuleCollectionsDeleteFuture) result(client AdminRuleCollectionsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.AdminRuleCollectionsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.AdminRuleCollectionsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// AdminRuleListResult security configuration admin rule list result.
type AdminRuleListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of admin rules
	Value *[]BasicBaseAdminRule `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for AdminRuleListResult struct.
func (arlr *AdminRuleListResult) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "value":
			if v != nil {
				value, err := unmarshalBasicBaseAdminRuleArray(*v)
				if err != nil {
					return err
				}
				arlr.Value = &value
			}
		case "nextLink":
			if v != nil {
				var nextLink string
				err = json.Unmarshal(*v, &nextLink)
				if err != nil {
					return err
				}
				arlr.NextLink = &nextLink
			}
		}
	}

	return nil
}

// AdminRuleListResultIterator provides access to a complete listing of BaseAdminRule values.
type AdminRuleListResultIterator struct {
	i    int
	page AdminRuleListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *AdminRuleListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AdminRuleListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *AdminRuleListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter AdminRuleListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter AdminRuleListResultIterator) Response() AdminRuleListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter AdminRuleListResultIterator) Value() BasicBaseAdminRule {
	if !iter.page.NotDone() {
		return BaseAdminRule{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the AdminRuleListResultIterator type.
func NewAdminRuleListResultIterator(page AdminRuleListResultPage) AdminRuleListResultIterator {
	return AdminRuleListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (arlr AdminRuleListResult) IsEmpty() bool {
	return arlr.Value == nil || len(*arlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (arlr AdminRuleListResult) hasNextLink() bool {
	return arlr.NextLink != nil && len(*arlr.NextLink) != 0
}

// adminRuleListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (arlr AdminRuleListResult) adminRuleListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !arlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(arlr.NextLink)))
}

// AdminRuleListResultPage contains a page of BasicBaseAdminRule values.
type AdminRuleListResultPage struct {
	fn   func(context.Context, AdminRuleListResult) (AdminRuleListResult, error)
	arlr AdminRuleListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *AdminRuleListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AdminRuleListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.arlr)
		if err != nil {
			return err
		}
		page.arlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *AdminRuleListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page AdminRuleListResultPage) NotDone() bool {
	return !page.arlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page AdminRuleListResultPage) Response() AdminRuleListResult {
	return page.arlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page AdminRuleListResultPage) Values() []BasicBaseAdminRule {
	if page.arlr.IsEmpty() {
		return nil
	}
	return *page.arlr.Value
}

// Creates a new instance of the AdminRuleListResultPage type.
func NewAdminRuleListResultPage(cur AdminRuleListResult, getNextPage func(context.Context, AdminRuleListResult) (AdminRuleListResult, error)) AdminRuleListResultPage {
	return AdminRuleListResultPage{
		fn:   getNextPage,
		arlr: cur,
	}
}

// AdminRulesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type AdminRulesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AdminRulesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AdminRulesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AdminRulesDeleteFuture.Result.
func (future *AdminRulesDeleteFuture) result(client AdminRulesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.AdminRulesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.AdminRulesDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// BasicBaseAdminRule network base admin rule.
type BasicBaseAdminRule interface {
	AsAdminRule() (*AdminRule, bool)
	AsDefaultAdminRule() (*DefaultAdminRule, bool)
	AsBaseAdminRule() (*BaseAdminRule, bool)
}

// BaseAdminRule network base admin rule.
type BaseAdminRule struct {
	autorest.Response `json:"-"`
	// SystemData - READ-ONLY; The system metadata related to this resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Kind - Possible values include: 'KindBasicBaseAdminRuleKindBaseAdminRule', 'KindBasicBaseAdminRuleKindCustom', 'KindBasicBaseAdminRuleKindDefault'
	Kind KindBasicBaseAdminRule `json:"kind,omitempty"`
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
}

func unmarshalBasicBaseAdminRule(body []byte) (BasicBaseAdminRule, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["kind"] {
	case string(KindBasicBaseAdminRuleKindCustom):
		var ar AdminRule
		err := json.Unmarshal(body, &ar)
		return ar, err
	case string(KindBasicBaseAdminRuleKindDefault):
		var dar DefaultAdminRule
		err := json.Unmarshal(body, &dar)
		return dar, err
	default:
		var bar BaseAdminRule
		err := json.Unmarshal(body, &bar)
		return bar, err
	}
}
func unmarshalBasicBaseAdminRuleArray(body []byte) ([]BasicBaseAdminRule, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	barArray := make([]BasicBaseAdminRule, len(rawMessages))

	for index, rawMessage := range rawMessages {
		bar, err := unmarshalBasicBaseAdminRule(*rawMessage)
		if err != nil {
			return nil, err
		}
		barArray[index] = bar
	}
	return barArray, nil
}

// MarshalJSON is the custom marshaler for BaseAdminRule.
func (bar BaseAdminRule) MarshalJSON() ([]byte, error) {
	bar.Kind = KindBasicBaseAdminRuleKindBaseAdminRule
	objectMap := make(map[string]interface{})
	if bar.Kind != "" {
		objectMap["kind"] = bar.Kind
	}
	return json.Marshal(objectMap)
}

// AsAdminRule is the BasicBaseAdminRule implementation for BaseAdminRule.
func (bar BaseAdminRule) AsAdminRule() (*AdminRule, bool) {
	return nil, false
}

// AsDefaultAdminRule is the BasicBaseAdminRule implementation for BaseAdminRule.
func (bar BaseAdminRule) AsDefaultAdminRule() (*DefaultAdminRule, bool) {
	return nil, false
}

// AsBaseAdminRule is the BasicBaseAdminRule implementation for BaseAdminRule.
func (bar BaseAdminRule) AsBaseAdminRule() (*BaseAdminRule, bool) {
	return &bar, true
}

// AsBasicBaseAdminRule is the BasicBaseAdminRule implementation for BaseAdminRule.
func (bar BaseAdminRule) AsBasicBaseAdminRule() (BasicBaseAdminRule, bool) {
	return &bar, true
}

// BaseAdminRuleModel ...
type BaseAdminRuleModel struct {
	autorest.Response `json:"-"`
	Value             BasicBaseAdminRule `json:"value,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for BaseAdminRuleModel struct.
func (barm *BaseAdminRuleModel) UnmarshalJSON(body []byte) error {
	bar, err := unmarshalBasicBaseAdminRule(body)
	if err != nil {
		return err
	}
	barm.Value = bar

	return nil
}

// ChildResource proxy resource representation.
type ChildResource struct {
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
}

// MarshalJSON is the custom marshaler for ChildResource.
func (cr ChildResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// CloudError an error response from the service.
type CloudError struct {
	// Error - Cloud error body.
	Error *CloudErrorBody `json:"error,omitempty"`
}

// CloudErrorBody an error response from the service.
type CloudErrorBody struct {
	// Code - An identifier for the error. Codes are invariant and are intended to be consumed programmatically.
	Code *string `json:"code,omitempty"`
	// Message - A message describing the error, intended to be suitable for display in a user interface.
	Message *string `json:"message,omitempty"`
	// Target - The target of the particular error. For example, the name of the property in error.
	Target *string `json:"target,omitempty"`
	// Details - A list of additional details about the error.
	Details *[]CloudErrorBody `json:"details,omitempty"`
}

// ConfigurationGroup the network configuration group resource
type ConfigurationGroup struct {
	// ID - Network group ID.
	ID *string `json:"id,omitempty"`
	// GroupProperties - The network configuration group properties
	*GroupProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for ConfigurationGroup.
func (cg ConfigurationGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cg.ID != nil {
		objectMap["id"] = cg.ID
	}
	if cg.GroupProperties != nil {
		objectMap["properties"] = cg.GroupProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ConfigurationGroup struct.
func (cg *ConfigurationGroup) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				cg.ID = &ID
			}
		case "properties":
			if v != nil {
				var groupProperties GroupProperties
				err = json.Unmarshal(*v, &groupProperties)
				if err != nil {
					return err
				}
				cg.GroupProperties = &groupProperties
			}
		}
	}

	return nil
}

// ConnectivityConfiguration the network manager connectivity configuration resource
type ConnectivityConfiguration struct {
	autorest.Response `json:"-"`
	// ConnectivityConfigurationProperties - Properties of a network manager connectivity configuration
	*ConnectivityConfigurationProperties `json:"properties,omitempty"`
	// SystemData - READ-ONLY; The system metadata related to this resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
}

// MarshalJSON is the custom marshaler for ConnectivityConfiguration.
func (cc ConnectivityConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cc.ConnectivityConfigurationProperties != nil {
		objectMap["properties"] = cc.ConnectivityConfigurationProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ConnectivityConfiguration struct.
func (cc *ConnectivityConfiguration) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var connectivityConfigurationProperties ConnectivityConfigurationProperties
				err = json.Unmarshal(*v, &connectivityConfigurationProperties)
				if err != nil {
					return err
				}
				cc.ConnectivityConfigurationProperties = &connectivityConfigurationProperties
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				cc.SystemData = &systemData
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				cc.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				cc.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				cc.Type = &typeVar
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				cc.Etag = &etag
			}
		}
	}

	return nil
}

// ConnectivityConfigurationListResult result of the request to list network manager connectivity
// configurations. It contains a list of configurations and a link to get the next set of results.
type ConnectivityConfigurationListResult struct {
	autorest.Response `json:"-"`
	// Value - Gets a page of Connectivity Configurations
	Value *[]ConnectivityConfiguration `json:"value,omitempty"`
	// NextLink - Gets the URL to get the next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// ConnectivityConfigurationListResultIterator provides access to a complete listing of
// ConnectivityConfiguration values.
type ConnectivityConfigurationListResultIterator struct {
	i    int
	page ConnectivityConfigurationListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ConnectivityConfigurationListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ConnectivityConfigurationListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ConnectivityConfigurationListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ConnectivityConfigurationListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ConnectivityConfigurationListResultIterator) Response() ConnectivityConfigurationListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ConnectivityConfigurationListResultIterator) Value() ConnectivityConfiguration {
	if !iter.page.NotDone() {
		return ConnectivityConfiguration{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ConnectivityConfigurationListResultIterator type.
func NewConnectivityConfigurationListResultIterator(page ConnectivityConfigurationListResultPage) ConnectivityConfigurationListResultIterator {
	return ConnectivityConfigurationListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (cclr ConnectivityConfigurationListResult) IsEmpty() bool {
	return cclr.Value == nil || len(*cclr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (cclr ConnectivityConfigurationListResult) hasNextLink() bool {
	return cclr.NextLink != nil && len(*cclr.NextLink) != 0
}

// connectivityConfigurationListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (cclr ConnectivityConfigurationListResult) connectivityConfigurationListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !cclr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(cclr.NextLink)))
}

// ConnectivityConfigurationListResultPage contains a page of ConnectivityConfiguration values.
type ConnectivityConfigurationListResultPage struct {
	fn   func(context.Context, ConnectivityConfigurationListResult) (ConnectivityConfigurationListResult, error)
	cclr ConnectivityConfigurationListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ConnectivityConfigurationListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ConnectivityConfigurationListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.cclr)
		if err != nil {
			return err
		}
		page.cclr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ConnectivityConfigurationListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ConnectivityConfigurationListResultPage) NotDone() bool {
	return !page.cclr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ConnectivityConfigurationListResultPage) Response() ConnectivityConfigurationListResult {
	return page.cclr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ConnectivityConfigurationListResultPage) Values() []ConnectivityConfiguration {
	if page.cclr.IsEmpty() {
		return nil
	}
	return *page.cclr.Value
}

// Creates a new instance of the ConnectivityConfigurationListResultPage type.
func NewConnectivityConfigurationListResultPage(cur ConnectivityConfigurationListResult, getNextPage func(context.Context, ConnectivityConfigurationListResult) (ConnectivityConfigurationListResult, error)) ConnectivityConfigurationListResultPage {
	return ConnectivityConfigurationListResultPage{
		fn:   getNextPage,
		cclr: cur,
	}
}

// ConnectivityConfigurationProperties properties of network manager connectivity configuration
type ConnectivityConfigurationProperties struct {
	// Description - A description of the connectivity configuration.
	Description *string `json:"description,omitempty"`
	// ConnectivityTopology - Connectivity topology type. Possible values include: 'ConnectivityTopologyHubAndSpoke', 'ConnectivityTopologyMesh'
	ConnectivityTopology ConnectivityTopology `json:"connectivityTopology,omitempty"`
	// Hubs - List of hubItems
	Hubs *[]Hub `json:"hubs,omitempty"`
	// IsGlobal - Flag if global mesh is supported. Possible values include: 'IsGlobalFalse', 'IsGlobalTrue'
	IsGlobal IsGlobal `json:"isGlobal,omitempty"`
	// AppliesToGroups - Groups for configuration
	AppliesToGroups *[]ConnectivityGroupItem `json:"appliesToGroups,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the connectivity configuration resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// DeleteExistingPeering - Flag if need to remove current existing peerings. Possible values include: 'DeleteExistingPeeringFalse', 'DeleteExistingPeeringTrue'
	DeleteExistingPeering DeleteExistingPeering `json:"deleteExistingPeering,omitempty"`
}

// MarshalJSON is the custom marshaler for ConnectivityConfigurationProperties.
func (ccp ConnectivityConfigurationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ccp.Description != nil {
		objectMap["description"] = ccp.Description
	}
	if ccp.ConnectivityTopology != "" {
		objectMap["connectivityTopology"] = ccp.ConnectivityTopology
	}
	if ccp.Hubs != nil {
		objectMap["hubs"] = ccp.Hubs
	}
	if ccp.IsGlobal != "" {
		objectMap["isGlobal"] = ccp.IsGlobal
	}
	if ccp.AppliesToGroups != nil {
		objectMap["appliesToGroups"] = ccp.AppliesToGroups
	}
	if ccp.DeleteExistingPeering != "" {
		objectMap["deleteExistingPeering"] = ccp.DeleteExistingPeering
	}
	return json.Marshal(objectMap)
}

// ConnectivityConfigurationsDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type ConnectivityConfigurationsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ConnectivityConfigurationsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ConnectivityConfigurationsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ConnectivityConfigurationsDeleteFuture.Result.
func (future *ConnectivityConfigurationsDeleteFuture) result(client ConnectivityConfigurationsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ConnectivityConfigurationsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ConnectivityConfigurationsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ConnectivityGroupItem connectivity group item.
type ConnectivityGroupItem struct {
	// NetworkGroupID - Network group Id.
	NetworkGroupID *string `json:"networkGroupId,omitempty"`
	// UseHubGateway - Flag if need to use hub gateway. Possible values include: 'UseHubGatewayFalse', 'UseHubGatewayTrue'
	UseHubGateway UseHubGateway `json:"useHubGateway,omitempty"`
	// IsGlobal - Flag if global is supported. Possible values include: 'IsGlobalFalse', 'IsGlobalTrue'
	IsGlobal IsGlobal `json:"isGlobal,omitempty"`
	// GroupConnectivity - Group connectivity type. Possible values include: 'GroupConnectivityNone', 'GroupConnectivityDirectlyConnected'
	GroupConnectivity GroupConnectivity `json:"groupConnectivity,omitempty"`
}

// CrossTenantScopes cross tenant scopes.
type CrossTenantScopes struct {
	// TenantID - READ-ONLY; Tenant ID.
	TenantID *string `json:"tenantId,omitempty"`
	// ManagementGroups - READ-ONLY; List of management groups.
	ManagementGroups *[]string `json:"managementGroups,omitempty"`
	// Subscriptions - READ-ONLY; List of subscriptions.
	Subscriptions *[]string `json:"subscriptions,omitempty"`
}

// MarshalJSON is the custom marshaler for CrossTenantScopes.
func (cts CrossTenantScopes) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// DefaultAdminPropertiesFormat security default admin rule resource.
type DefaultAdminPropertiesFormat struct {
	// Description - READ-ONLY; A description for this rule. Restricted to 140 chars.
	Description *string `json:"description,omitempty"`
	// Flag - Default rule flag.
	Flag *string `json:"flag,omitempty"`
	// Protocol - READ-ONLY; Network protocol this rule applies to. Possible values include: 'SecurityConfigurationRuleProtocolTCP', 'SecurityConfigurationRuleProtocolUDP', 'SecurityConfigurationRuleProtocolIcmp', 'SecurityConfigurationRuleProtocolEsp', 'SecurityConfigurationRuleProtocolAny', 'SecurityConfigurationRuleProtocolAh'
	Protocol SecurityConfigurationRuleProtocol `json:"protocol,omitempty"`
	// Sources - READ-ONLY; The CIDR or source IP ranges.
	Sources *[]AddressPrefixItem `json:"sources,omitempty"`
	// Destinations - READ-ONLY; The destination address prefixes. CIDR or destination IP ranges.
	Destinations *[]AddressPrefixItem `json:"destinations,omitempty"`
	// SourcePortRanges - READ-ONLY; The source port ranges.
	SourcePortRanges *[]string `json:"sourcePortRanges,omitempty"`
	// DestinationPortRanges - READ-ONLY; The destination port ranges.
	DestinationPortRanges *[]string `json:"destinationPortRanges,omitempty"`
	// Access - READ-ONLY; Indicates the access allowed for this particular rule. Possible values include: 'SecurityConfigurationRuleAccessAllow', 'SecurityConfigurationRuleAccessDeny', 'SecurityConfigurationRuleAccessAlwaysAllow'
	Access SecurityConfigurationRuleAccess `json:"access,omitempty"`
	// Priority - READ-ONLY; The priority of the rule. The value can be between 1 and 4096. The priority number must be unique for each rule in the collection. The lower the priority number, the higher the priority of the rule.
	Priority *int32 `json:"priority,omitempty"`
	// Direction - READ-ONLY; Indicates if the traffic matched against the rule in inbound or outbound. Possible values include: 'SecurityConfigurationRuleDirectionInbound', 'SecurityConfigurationRuleDirectionOutbound'
	Direction SecurityConfigurationRuleDirection `json:"direction,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for DefaultAdminPropertiesFormat.
func (dapf DefaultAdminPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dapf.Flag != nil {
		objectMap["flag"] = dapf.Flag
	}
	return json.Marshal(objectMap)
}

// DefaultAdminRule network default admin rule.
type DefaultAdminRule struct {
	// DefaultAdminPropertiesFormat - Indicates the properties of the security admin rule
	*DefaultAdminPropertiesFormat `json:"properties,omitempty"`
	// SystemData - READ-ONLY; The system metadata related to this resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Kind - Possible values include: 'KindBasicBaseAdminRuleKindBaseAdminRule', 'KindBasicBaseAdminRuleKindCustom', 'KindBasicBaseAdminRuleKindDefault'
	Kind KindBasicBaseAdminRule `json:"kind,omitempty"`
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
}

// MarshalJSON is the custom marshaler for DefaultAdminRule.
func (dar DefaultAdminRule) MarshalJSON() ([]byte, error) {
	dar.Kind = KindBasicBaseAdminRuleKindDefault
	objectMap := make(map[string]interface{})
	if dar.DefaultAdminPropertiesFormat != nil {
		objectMap["properties"] = dar.DefaultAdminPropertiesFormat
	}
	if dar.Kind != "" {
		objectMap["kind"] = dar.Kind
	}
	return json.Marshal(objectMap)
}

// AsAdminRule is the BasicBaseAdminRule implementation for DefaultAdminRule.
func (dar DefaultAdminRule) AsAdminRule() (*AdminRule, bool) {
	return nil, false
}

// AsDefaultAdminRule is the BasicBaseAdminRule implementation for DefaultAdminRule.
func (dar DefaultAdminRule) AsDefaultAdminRule() (*DefaultAdminRule, bool) {
	return &dar, true
}

// AsBaseAdminRule is the BasicBaseAdminRule implementation for DefaultAdminRule.
func (dar DefaultAdminRule) AsBaseAdminRule() (*BaseAdminRule, bool) {
	return nil, false
}

// AsBasicBaseAdminRule is the BasicBaseAdminRule implementation for DefaultAdminRule.
func (dar DefaultAdminRule) AsBasicBaseAdminRule() (BasicBaseAdminRule, bool) {
	return &dar, true
}

// UnmarshalJSON is the custom unmarshaler for DefaultAdminRule struct.
func (dar *DefaultAdminRule) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var defaultAdminPropertiesFormat DefaultAdminPropertiesFormat
				err = json.Unmarshal(*v, &defaultAdminPropertiesFormat)
				if err != nil {
					return err
				}
				dar.DefaultAdminPropertiesFormat = &defaultAdminPropertiesFormat
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				dar.SystemData = &systemData
			}
		case "kind":
			if v != nil {
				var kind KindBasicBaseAdminRule
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				dar.Kind = kind
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				dar.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				dar.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				dar.Type = &typeVar
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				dar.Etag = &etag
			}
		}
	}

	return nil
}

// BasicEffectiveBaseSecurityAdminRule network base admin rule.
type BasicEffectiveBaseSecurityAdminRule interface {
	AsEffectiveSecurityAdminRule() (*EffectiveSecurityAdminRule, bool)
	AsEffectiveDefaultSecurityAdminRule() (*EffectiveDefaultSecurityAdminRule, bool)
	AsEffectiveBaseSecurityAdminRule() (*EffectiveBaseSecurityAdminRule, bool)
}

// EffectiveBaseSecurityAdminRule network base admin rule.
type EffectiveBaseSecurityAdminRule struct {
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// ConfigurationDescription - A description of the security admin configuration.
	ConfigurationDescription *string `json:"configurationDescription,omitempty"`
	// RuleCollectionDescription - A description of the rule collection.
	RuleCollectionDescription *string `json:"ruleCollectionDescription,omitempty"`
	// RuleCollectionAppliesToGroups - Groups for rule collection
	RuleCollectionAppliesToGroups *[]ManagerSecurityGroupItem `json:"ruleCollectionAppliesToGroups,omitempty"`
	// RuleGroups - Effective configuration groups.
	RuleGroups *[]ConfigurationGroup `json:"ruleGroups,omitempty"`
	// Kind - Possible values include: 'KindBasicEffectiveBaseSecurityAdminRuleKindEffectiveBaseSecurityAdminRule', 'KindBasicEffectiveBaseSecurityAdminRuleKindCustom', 'KindBasicEffectiveBaseSecurityAdminRuleKindDefault'
	Kind KindBasicEffectiveBaseSecurityAdminRule `json:"kind,omitempty"`
}

func unmarshalBasicEffectiveBaseSecurityAdminRule(body []byte) (BasicEffectiveBaseSecurityAdminRule, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["kind"] {
	case string(KindBasicEffectiveBaseSecurityAdminRuleKindCustom):
		var esar EffectiveSecurityAdminRule
		err := json.Unmarshal(body, &esar)
		return esar, err
	case string(KindBasicEffectiveBaseSecurityAdminRuleKindDefault):
		var edsar EffectiveDefaultSecurityAdminRule
		err := json.Unmarshal(body, &edsar)
		return edsar, err
	default:
		var ebsar EffectiveBaseSecurityAdminRule
		err := json.Unmarshal(body, &ebsar)
		return ebsar, err
	}
}
func unmarshalBasicEffectiveBaseSecurityAdminRuleArray(body []byte) ([]BasicEffectiveBaseSecurityAdminRule, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	ebsarArray := make([]BasicEffectiveBaseSecurityAdminRule, len(rawMessages))

	for index, rawMessage := range rawMessages {
		ebsar, err := unmarshalBasicEffectiveBaseSecurityAdminRule(*rawMessage)
		if err != nil {
			return nil, err
		}
		ebsarArray[index] = ebsar
	}
	return ebsarArray, nil
}

// MarshalJSON is the custom marshaler for EffectiveBaseSecurityAdminRule.
func (ebsar EffectiveBaseSecurityAdminRule) MarshalJSON() ([]byte, error) {
	ebsar.Kind = KindBasicEffectiveBaseSecurityAdminRuleKindEffectiveBaseSecurityAdminRule
	objectMap := make(map[string]interface{})
	if ebsar.ID != nil {
		objectMap["id"] = ebsar.ID
	}
	if ebsar.ConfigurationDescription != nil {
		objectMap["configurationDescription"] = ebsar.ConfigurationDescription
	}
	if ebsar.RuleCollectionDescription != nil {
		objectMap["ruleCollectionDescription"] = ebsar.RuleCollectionDescription
	}
	if ebsar.RuleCollectionAppliesToGroups != nil {
		objectMap["ruleCollectionAppliesToGroups"] = ebsar.RuleCollectionAppliesToGroups
	}
	if ebsar.RuleGroups != nil {
		objectMap["ruleGroups"] = ebsar.RuleGroups
	}
	if ebsar.Kind != "" {
		objectMap["kind"] = ebsar.Kind
	}
	return json.Marshal(objectMap)
}

// AsEffectiveSecurityAdminRule is the BasicEffectiveBaseSecurityAdminRule implementation for EffectiveBaseSecurityAdminRule.
func (ebsar EffectiveBaseSecurityAdminRule) AsEffectiveSecurityAdminRule() (*EffectiveSecurityAdminRule, bool) {
	return nil, false
}

// AsEffectiveDefaultSecurityAdminRule is the BasicEffectiveBaseSecurityAdminRule implementation for EffectiveBaseSecurityAdminRule.
func (ebsar EffectiveBaseSecurityAdminRule) AsEffectiveDefaultSecurityAdminRule() (*EffectiveDefaultSecurityAdminRule, bool) {
	return nil, false
}

// AsEffectiveBaseSecurityAdminRule is the BasicEffectiveBaseSecurityAdminRule implementation for EffectiveBaseSecurityAdminRule.
func (ebsar EffectiveBaseSecurityAdminRule) AsEffectiveBaseSecurityAdminRule() (*EffectiveBaseSecurityAdminRule, bool) {
	return &ebsar, true
}

// AsBasicEffectiveBaseSecurityAdminRule is the BasicEffectiveBaseSecurityAdminRule implementation for EffectiveBaseSecurityAdminRule.
func (ebsar EffectiveBaseSecurityAdminRule) AsBasicEffectiveBaseSecurityAdminRule() (BasicEffectiveBaseSecurityAdminRule, bool) {
	return &ebsar, true
}

// EffectiveConnectivityConfiguration the network manager effective connectivity configuration
type EffectiveConnectivityConfiguration struct {
	// ID - Connectivity configuration ID.
	ID *string `json:"id,omitempty"`
	// ConnectivityConfigurationProperties - Properties of a network manager connectivity configuration
	*ConnectivityConfigurationProperties `json:"properties,omitempty"`
	// ConfigurationGroups - Effective configuration groups.
	ConfigurationGroups *[]ConfigurationGroup `json:"configurationGroups,omitempty"`
}

// MarshalJSON is the custom marshaler for EffectiveConnectivityConfiguration.
func (ecc EffectiveConnectivityConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ecc.ID != nil {
		objectMap["id"] = ecc.ID
	}
	if ecc.ConnectivityConfigurationProperties != nil {
		objectMap["properties"] = ecc.ConnectivityConfigurationProperties
	}
	if ecc.ConfigurationGroups != nil {
		objectMap["configurationGroups"] = ecc.ConfigurationGroups
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for EffectiveConnectivityConfiguration struct.
func (ecc *EffectiveConnectivityConfiguration) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ecc.ID = &ID
			}
		case "properties":
			if v != nil {
				var connectivityConfigurationProperties ConnectivityConfigurationProperties
				err = json.Unmarshal(*v, &connectivityConfigurationProperties)
				if err != nil {
					return err
				}
				ecc.ConnectivityConfigurationProperties = &connectivityConfigurationProperties
			}
		case "configurationGroups":
			if v != nil {
				var configurationGroups []ConfigurationGroup
				err = json.Unmarshal(*v, &configurationGroups)
				if err != nil {
					return err
				}
				ecc.ConfigurationGroups = &configurationGroups
			}
		}
	}

	return nil
}

// EffectiveDefaultSecurityAdminRule network default admin rule.
type EffectiveDefaultSecurityAdminRule struct {
	// DefaultAdminPropertiesFormat - Indicates the properties of the default security admin rule
	*DefaultAdminPropertiesFormat `json:"properties,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// ConfigurationDescription - A description of the security admin configuration.
	ConfigurationDescription *string `json:"configurationDescription,omitempty"`
	// RuleCollectionDescription - A description of the rule collection.
	RuleCollectionDescription *string `json:"ruleCollectionDescription,omitempty"`
	// RuleCollectionAppliesToGroups - Groups for rule collection
	RuleCollectionAppliesToGroups *[]ManagerSecurityGroupItem `json:"ruleCollectionAppliesToGroups,omitempty"`
	// RuleGroups - Effective configuration groups.
	RuleGroups *[]ConfigurationGroup `json:"ruleGroups,omitempty"`
	// Kind - Possible values include: 'KindBasicEffectiveBaseSecurityAdminRuleKindEffectiveBaseSecurityAdminRule', 'KindBasicEffectiveBaseSecurityAdminRuleKindCustom', 'KindBasicEffectiveBaseSecurityAdminRuleKindDefault'
	Kind KindBasicEffectiveBaseSecurityAdminRule `json:"kind,omitempty"`
}

// MarshalJSON is the custom marshaler for EffectiveDefaultSecurityAdminRule.
func (edsar EffectiveDefaultSecurityAdminRule) MarshalJSON() ([]byte, error) {
	edsar.Kind = KindBasicEffectiveBaseSecurityAdminRuleKindDefault
	objectMap := make(map[string]interface{})
	if edsar.DefaultAdminPropertiesFormat != nil {
		objectMap["properties"] = edsar.DefaultAdminPropertiesFormat
	}
	if edsar.ID != nil {
		objectMap["id"] = edsar.ID
	}
	if edsar.ConfigurationDescription != nil {
		objectMap["configurationDescription"] = edsar.ConfigurationDescription
	}
	if edsar.RuleCollectionDescription != nil {
		objectMap["ruleCollectionDescription"] = edsar.RuleCollectionDescription
	}
	if edsar.RuleCollectionAppliesToGroups != nil {
		objectMap["ruleCollectionAppliesToGroups"] = edsar.RuleCollectionAppliesToGroups
	}
	if edsar.RuleGroups != nil {
		objectMap["ruleGroups"] = edsar.RuleGroups
	}
	if edsar.Kind != "" {
		objectMap["kind"] = edsar.Kind
	}
	return json.Marshal(objectMap)
}

// AsEffectiveSecurityAdminRule is the BasicEffectiveBaseSecurityAdminRule implementation for EffectiveDefaultSecurityAdminRule.
func (edsar EffectiveDefaultSecurityAdminRule) AsEffectiveSecurityAdminRule() (*EffectiveSecurityAdminRule, bool) {
	return nil, false
}

// AsEffectiveDefaultSecurityAdminRule is the BasicEffectiveBaseSecurityAdminRule implementation for EffectiveDefaultSecurityAdminRule.
func (edsar EffectiveDefaultSecurityAdminRule) AsEffectiveDefaultSecurityAdminRule() (*EffectiveDefaultSecurityAdminRule, bool) {
	return &edsar, true
}

// AsEffectiveBaseSecurityAdminRule is the BasicEffectiveBaseSecurityAdminRule implementation for EffectiveDefaultSecurityAdminRule.
func (edsar EffectiveDefaultSecurityAdminRule) AsEffectiveBaseSecurityAdminRule() (*EffectiveBaseSecurityAdminRule, bool) {
	return nil, false
}

// AsBasicEffectiveBaseSecurityAdminRule is the BasicEffectiveBaseSecurityAdminRule implementation for EffectiveDefaultSecurityAdminRule.
func (edsar EffectiveDefaultSecurityAdminRule) AsBasicEffectiveBaseSecurityAdminRule() (BasicEffectiveBaseSecurityAdminRule, bool) {
	return &edsar, true
}

// UnmarshalJSON is the custom unmarshaler for EffectiveDefaultSecurityAdminRule struct.
func (edsar *EffectiveDefaultSecurityAdminRule) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var defaultAdminPropertiesFormat DefaultAdminPropertiesFormat
				err = json.Unmarshal(*v, &defaultAdminPropertiesFormat)
				if err != nil {
					return err
				}
				edsar.DefaultAdminPropertiesFormat = &defaultAdminPropertiesFormat
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				edsar.ID = &ID
			}
		case "configurationDescription":
			if v != nil {
				var configurationDescription string
				err = json.Unmarshal(*v, &configurationDescription)
				if err != nil {
					return err
				}
				edsar.ConfigurationDescription = &configurationDescription
			}
		case "ruleCollectionDescription":
			if v != nil {
				var ruleCollectionDescription string
				err = json.Unmarshal(*v, &ruleCollectionDescription)
				if err != nil {
					return err
				}
				edsar.RuleCollectionDescription = &ruleCollectionDescription
			}
		case "ruleCollectionAppliesToGroups":
			if v != nil {
				var ruleCollectionAppliesToGroups []ManagerSecurityGroupItem
				err = json.Unmarshal(*v, &ruleCollectionAppliesToGroups)
				if err != nil {
					return err
				}
				edsar.RuleCollectionAppliesToGroups = &ruleCollectionAppliesToGroups
			}
		case "ruleGroups":
			if v != nil {
				var ruleGroups []ConfigurationGroup
				err = json.Unmarshal(*v, &ruleGroups)
				if err != nil {
					return err
				}
				edsar.RuleGroups = &ruleGroups
			}
		case "kind":
			if v != nil {
				var kind KindBasicEffectiveBaseSecurityAdminRule
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				edsar.Kind = kind
			}
		}
	}

	return nil
}

// EffectiveSecurityAdminRule network admin rule.
type EffectiveSecurityAdminRule struct {
	// AdminPropertiesFormat - Indicates the properties of the security admin rule
	*AdminPropertiesFormat `json:"properties,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// ConfigurationDescription - A description of the security admin configuration.
	ConfigurationDescription *string `json:"configurationDescription,omitempty"`
	// RuleCollectionDescription - A description of the rule collection.
	RuleCollectionDescription *string `json:"ruleCollectionDescription,omitempty"`
	// RuleCollectionAppliesToGroups - Groups for rule collection
	RuleCollectionAppliesToGroups *[]ManagerSecurityGroupItem `json:"ruleCollectionAppliesToGroups,omitempty"`
	// RuleGroups - Effective configuration groups.
	RuleGroups *[]ConfigurationGroup `json:"ruleGroups,omitempty"`
	// Kind - Possible values include: 'KindBasicEffectiveBaseSecurityAdminRuleKindEffectiveBaseSecurityAdminRule', 'KindBasicEffectiveBaseSecurityAdminRuleKindCustom', 'KindBasicEffectiveBaseSecurityAdminRuleKindDefault'
	Kind KindBasicEffectiveBaseSecurityAdminRule `json:"kind,omitempty"`
}

// MarshalJSON is the custom marshaler for EffectiveSecurityAdminRule.
func (esar EffectiveSecurityAdminRule) MarshalJSON() ([]byte, error) {
	esar.Kind = KindBasicEffectiveBaseSecurityAdminRuleKindCustom
	objectMap := make(map[string]interface{})
	if esar.AdminPropertiesFormat != nil {
		objectMap["properties"] = esar.AdminPropertiesFormat
	}
	if esar.ID != nil {
		objectMap["id"] = esar.ID
	}
	if esar.ConfigurationDescription != nil {
		objectMap["configurationDescription"] = esar.ConfigurationDescription
	}
	if esar.RuleCollectionDescription != nil {
		objectMap["ruleCollectionDescription"] = esar.RuleCollectionDescription
	}
	if esar.RuleCollectionAppliesToGroups != nil {
		objectMap["ruleCollectionAppliesToGroups"] = esar.RuleCollectionAppliesToGroups
	}
	if esar.RuleGroups != nil {
		objectMap["ruleGroups"] = esar.RuleGroups
	}
	if esar.Kind != "" {
		objectMap["kind"] = esar.Kind
	}
	return json.Marshal(objectMap)
}

// AsEffectiveSecurityAdminRule is the BasicEffectiveBaseSecurityAdminRule implementation for EffectiveSecurityAdminRule.
func (esar EffectiveSecurityAdminRule) AsEffectiveSecurityAdminRule() (*EffectiveSecurityAdminRule, bool) {
	return &esar, true
}

// AsEffectiveDefaultSecurityAdminRule is the BasicEffectiveBaseSecurityAdminRule implementation for EffectiveSecurityAdminRule.
func (esar EffectiveSecurityAdminRule) AsEffectiveDefaultSecurityAdminRule() (*EffectiveDefaultSecurityAdminRule, bool) {
	return nil, false
}

// AsEffectiveBaseSecurityAdminRule is the BasicEffectiveBaseSecurityAdminRule implementation for EffectiveSecurityAdminRule.
func (esar EffectiveSecurityAdminRule) AsEffectiveBaseSecurityAdminRule() (*EffectiveBaseSecurityAdminRule, bool) {
	return nil, false
}

// AsBasicEffectiveBaseSecurityAdminRule is the BasicEffectiveBaseSecurityAdminRule implementation for EffectiveSecurityAdminRule.
func (esar EffectiveSecurityAdminRule) AsBasicEffectiveBaseSecurityAdminRule() (BasicEffectiveBaseSecurityAdminRule, bool) {
	return &esar, true
}

// UnmarshalJSON is the custom unmarshaler for EffectiveSecurityAdminRule struct.
func (esar *EffectiveSecurityAdminRule) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var adminPropertiesFormat AdminPropertiesFormat
				err = json.Unmarshal(*v, &adminPropertiesFormat)
				if err != nil {
					return err
				}
				esar.AdminPropertiesFormat = &adminPropertiesFormat
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				esar.ID = &ID
			}
		case "configurationDescription":
			if v != nil {
				var configurationDescription string
				err = json.Unmarshal(*v, &configurationDescription)
				if err != nil {
					return err
				}
				esar.ConfigurationDescription = &configurationDescription
			}
		case "ruleCollectionDescription":
			if v != nil {
				var ruleCollectionDescription string
				err = json.Unmarshal(*v, &ruleCollectionDescription)
				if err != nil {
					return err
				}
				esar.RuleCollectionDescription = &ruleCollectionDescription
			}
		case "ruleCollectionAppliesToGroups":
			if v != nil {
				var ruleCollectionAppliesToGroups []ManagerSecurityGroupItem
				err = json.Unmarshal(*v, &ruleCollectionAppliesToGroups)
				if err != nil {
					return err
				}
				esar.RuleCollectionAppliesToGroups = &ruleCollectionAppliesToGroups
			}
		case "ruleGroups":
			if v != nil {
				var ruleGroups []ConfigurationGroup
				err = json.Unmarshal(*v, &ruleGroups)
				if err != nil {
					return err
				}
				esar.RuleGroups = &ruleGroups
			}
		case "kind":
			if v != nil {
				var kind KindBasicEffectiveBaseSecurityAdminRule
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				esar.Kind = kind
			}
		}
	}

	return nil
}

// Group the network group resource
type Group struct {
	autorest.Response `json:"-"`
	// GroupProperties - The Network Group properties
	*GroupProperties `json:"properties,omitempty"`
	// SystemData - READ-ONLY; The system metadata related to this resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
}

// MarshalJSON is the custom marshaler for Group.
func (g Group) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if g.GroupProperties != nil {
		objectMap["properties"] = g.GroupProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Group struct.
func (g *Group) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var groupProperties GroupProperties
				err = json.Unmarshal(*v, &groupProperties)
				if err != nil {
					return err
				}
				g.GroupProperties = &groupProperties
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				g.SystemData = &systemData
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				g.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				g.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				g.Type = &typeVar
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				g.Etag = &etag
			}
		}
	}

	return nil
}

// GroupListResult result of the request to list NetworkGroup. It contains a list of groups and a URL link
// to get the next set of results.
type GroupListResult struct {
	autorest.Response `json:"-"`
	// Value - Gets a page of NetworkGroup
	Value *[]Group `json:"value,omitempty"`
	// NextLink - Gets the URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// GroupListResultIterator provides access to a complete listing of Group values.
type GroupListResultIterator struct {
	i    int
	page GroupListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *GroupListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/GroupListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *GroupListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter GroupListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter GroupListResultIterator) Response() GroupListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter GroupListResultIterator) Value() Group {
	if !iter.page.NotDone() {
		return Group{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the GroupListResultIterator type.
func NewGroupListResultIterator(page GroupListResultPage) GroupListResultIterator {
	return GroupListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (glr GroupListResult) IsEmpty() bool {
	return glr.Value == nil || len(*glr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (glr GroupListResult) hasNextLink() bool {
	return glr.NextLink != nil && len(*glr.NextLink) != 0
}

// groupListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (glr GroupListResult) groupListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !glr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(glr.NextLink)))
}

// GroupListResultPage contains a page of Group values.
type GroupListResultPage struct {
	fn  func(context.Context, GroupListResult) (GroupListResult, error)
	glr GroupListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *GroupListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/GroupListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.glr)
		if err != nil {
			return err
		}
		page.glr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *GroupListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page GroupListResultPage) NotDone() bool {
	return !page.glr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page GroupListResultPage) Response() GroupListResult {
	return page.glr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page GroupListResultPage) Values() []Group {
	if page.glr.IsEmpty() {
		return nil
	}
	return *page.glr.Value
}

// Creates a new instance of the GroupListResultPage type.
func NewGroupListResultPage(cur GroupListResult, getNextPage func(context.Context, GroupListResult) (GroupListResult, error)) GroupListResultPage {
	return GroupListResultPage{
		fn:  getNextPage,
		glr: cur,
	}
}

// GroupProperties properties of network group
type GroupProperties struct {
	// Description - A description of the network group.
	Description *string `json:"description,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the scope assignment resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for GroupProperties.
func (gp GroupProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if gp.Description != nil {
		objectMap["description"] = gp.Description
	}
	return json.Marshal(objectMap)
}

// GroupsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type GroupsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(GroupsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *GroupsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for GroupsDeleteFuture.Result.
func (future *GroupsDeleteFuture) result(client GroupsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.GroupsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.GroupsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// Hub hub Item.
type Hub struct {
	// ResourceID - Resource Id.
	ResourceID *string `json:"resourceId,omitempty"`
	// ResourceType - Resource Type.
	ResourceType *string `json:"resourceType,omitempty"`
}

// Manager the Managed Network resource
type Manager struct {
	autorest.Response `json:"-"`
	// ManagerProperties - The network manager properties
	*ManagerProperties `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// SystemData - READ-ONLY; The system metadata related to this resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for Manager.
func (mVar Manager) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if mVar.ManagerProperties != nil {
		objectMap["properties"] = mVar.ManagerProperties
	}
	if mVar.ID != nil {
		objectMap["id"] = mVar.ID
	}
	if mVar.Location != nil {
		objectMap["location"] = mVar.Location
	}
	if mVar.Tags != nil {
		objectMap["tags"] = mVar.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Manager struct.
func (mVar *Manager) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var managerProperties ManagerProperties
				err = json.Unmarshal(*v, &managerProperties)
				if err != nil {
					return err
				}
				mVar.ManagerProperties = &managerProperties
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				mVar.Etag = &etag
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				mVar.SystemData = &systemData
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				mVar.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				mVar.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				mVar.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				mVar.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				mVar.Tags = tags
			}
		}
	}

	return nil
}

// ManagerCommit network Manager Commit.
type ManagerCommit struct {
	autorest.Response `json:"-"`
	// CommitID - READ-ONLY; Commit Id.
	CommitID *string `json:"commitId,omitempty"`
	// TargetLocations - List of target locations.
	TargetLocations *[]string `json:"targetLocations,omitempty"`
	// ConfigurationIds - List of configuration ids.
	ConfigurationIds *[]string `json:"configurationIds,omitempty"`
	// CommitType - Commit Type. Possible values include: 'ConfigurationTypeSecurityAdmin', 'ConfigurationTypeConnectivity'
	CommitType ConfigurationType `json:"commitType,omitempty"`
}

// MarshalJSON is the custom marshaler for ManagerCommit.
func (mc ManagerCommit) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if mc.TargetLocations != nil {
		objectMap["targetLocations"] = mc.TargetLocations
	}
	if mc.ConfigurationIds != nil {
		objectMap["configurationIds"] = mc.ConfigurationIds
	}
	if mc.CommitType != "" {
		objectMap["commitType"] = mc.CommitType
	}
	return json.Marshal(objectMap)
}

// ManagerCommitsPostFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ManagerCommitsPostFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ManagerCommitsClient) (ManagerCommit, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ManagerCommitsPostFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ManagerCommitsPostFuture.Result.
func (future *ManagerCommitsPostFuture) result(client ManagerCommitsClient) (mc ManagerCommit, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ManagerCommitsPostFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		mc.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ManagerCommitsPostFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if mc.Response.Response, err = future.GetResult(sender); err == nil && mc.Response.Response.StatusCode != http.StatusNoContent {
		mc, err = client.PostResponder(mc.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.ManagerCommitsPostFuture", "Result", mc.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ManagerConnection the Network Manager Connection resource
type ManagerConnection struct {
	autorest.Response `json:"-"`
	// ManagerConnectionProperties - The scope connection properties
	*ManagerConnectionProperties `json:"properties,omitempty"`
	// SystemData - READ-ONLY; The system metadata related to this resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
}

// MarshalJSON is the custom marshaler for ManagerConnection.
func (mc ManagerConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if mc.ManagerConnectionProperties != nil {
		objectMap["properties"] = mc.ManagerConnectionProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ManagerConnection struct.
func (mc *ManagerConnection) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var managerConnectionProperties ManagerConnectionProperties
				err = json.Unmarshal(*v, &managerConnectionProperties)
				if err != nil {
					return err
				}
				mc.ManagerConnectionProperties = &managerConnectionProperties
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				mc.SystemData = &systemData
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				mc.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				mc.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				mc.Type = &typeVar
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				mc.Etag = &etag
			}
		}
	}

	return nil
}

// ManagerConnectionListResult list of network manager connections.
type ManagerConnectionListResult struct {
	autorest.Response `json:"-"`
	// Value - List of network manager connections.
	Value *[]ManagerConnection `json:"value,omitempty"`
	// NextLink - Gets the URL to get the next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// ManagerConnectionListResultIterator provides access to a complete listing of ManagerConnection values.
type ManagerConnectionListResultIterator struct {
	i    int
	page ManagerConnectionListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ManagerConnectionListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ManagerConnectionListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ManagerConnectionListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ManagerConnectionListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ManagerConnectionListResultIterator) Response() ManagerConnectionListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ManagerConnectionListResultIterator) Value() ManagerConnection {
	if !iter.page.NotDone() {
		return ManagerConnection{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ManagerConnectionListResultIterator type.
func NewManagerConnectionListResultIterator(page ManagerConnectionListResultPage) ManagerConnectionListResultIterator {
	return ManagerConnectionListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (mclr ManagerConnectionListResult) IsEmpty() bool {
	return mclr.Value == nil || len(*mclr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (mclr ManagerConnectionListResult) hasNextLink() bool {
	return mclr.NextLink != nil && len(*mclr.NextLink) != 0
}

// managerConnectionListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (mclr ManagerConnectionListResult) managerConnectionListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !mclr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(mclr.NextLink)))
}

// ManagerConnectionListResultPage contains a page of ManagerConnection values.
type ManagerConnectionListResultPage struct {
	fn   func(context.Context, ManagerConnectionListResult) (ManagerConnectionListResult, error)
	mclr ManagerConnectionListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ManagerConnectionListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ManagerConnectionListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.mclr)
		if err != nil {
			return err
		}
		page.mclr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ManagerConnectionListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ManagerConnectionListResultPage) NotDone() bool {
	return !page.mclr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ManagerConnectionListResultPage) Response() ManagerConnectionListResult {
	return page.mclr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ManagerConnectionListResultPage) Values() []ManagerConnection {
	if page.mclr.IsEmpty() {
		return nil
	}
	return *page.mclr.Value
}

// Creates a new instance of the ManagerConnectionListResultPage type.
func NewManagerConnectionListResultPage(cur ManagerConnectionListResult, getNextPage func(context.Context, ManagerConnectionListResult) (ManagerConnectionListResult, error)) ManagerConnectionListResultPage {
	return ManagerConnectionListResultPage{
		fn:   getNextPage,
		mclr: cur,
	}
}

// ManagerConnectionProperties information about the network manager connection.
type ManagerConnectionProperties struct {
	// NetworkManagerID - Network Manager Id.
	NetworkManagerID *string `json:"networkManagerId,omitempty"`
	// ConnectionState - Connection state. Possible values include: 'ScopeConnectionStateConnected', 'ScopeConnectionStatePending', 'ScopeConnectionStateConflict', 'ScopeConnectionStateRevoked', 'ScopeConnectionStateRejected'
	ConnectionState ScopeConnectionState `json:"connectionState,omitempty"`
	// Description - A description of the network manager connection.
	Description *string `json:"description,omitempty"`
}

// ManagerDeploymentStatus network Manager Deployment Status.
type ManagerDeploymentStatus struct {
	// CommitTime - Commit Time.
	CommitTime *date.Time `json:"commitTime,omitempty"`
	// Region - Region Name.
	Region *string `json:"region,omitempty"`
	// DeploymentStatus - Deployment Status. Possible values include: 'DeploymentStatusNotStarted', 'DeploymentStatusDeploying', 'DeploymentStatusDeployed', 'DeploymentStatusFailed'
	DeploymentStatus DeploymentStatus `json:"deploymentStatus,omitempty"`
	// ConfigurationIds - List of configuration ids.
	ConfigurationIds *[]string `json:"configurationIds,omitempty"`
	// DeploymentType - Possible values include: 'ConfigurationTypeSecurityAdmin', 'ConfigurationTypeConnectivity'
	DeploymentType ConfigurationType `json:"deploymentType,omitempty"`
	// ErrorMessage - Error Message.
	ErrorMessage *string `json:"errorMessage,omitempty"`
}

// ManagerDeploymentStatusListResult a list of Network Manager Deployment Status
type ManagerDeploymentStatusListResult struct {
	autorest.Response `json:"-"`
	// Value - Gets a page of Network Manager Deployment Status
	Value *[]ManagerDeploymentStatus `json:"value,omitempty"`
	// SkipToken - When present, the value can be passed to a subsequent query call (together with the same query and scopes used in the current request) to retrieve the next page of data.
	SkipToken *string `json:"skipToken,omitempty"`
}

// ManagerDeploymentStatusParameter network Manager Deployment Status Parameter.
type ManagerDeploymentStatusParameter struct {
	// Regions - List of locations.
	Regions *[]string `json:"regions,omitempty"`
	// DeploymentTypes - List of deployment types.
	DeploymentTypes *[]ConfigurationType `json:"deploymentTypes,omitempty"`
	// SkipToken - Continuation token for pagination, capturing the next page size and offset, as well as the context of the query.
	SkipToken *string `json:"skipToken,omitempty"`
}

// ManagerEffectiveConnectivityConfigurationListResult result of the request to list
// networkManagerEffectiveConnectivityConfiguration. It contains a list of groups and a skiptoken to get
// the next set of results.
type ManagerEffectiveConnectivityConfigurationListResult struct {
	autorest.Response `json:"-"`
	// Value - Gets a page of NetworkManagerEffectiveConnectivityConfiguration
	Value *[]EffectiveConnectivityConfiguration `json:"value,omitempty"`
	// SkipToken - When present, the value can be passed to a subsequent query call (together with the same query and scopes used in the current request) to retrieve the next page of data.
	SkipToken *string `json:"skipToken,omitempty"`
}

// ManagerEffectiveSecurityAdminRulesListResult result of the request to list
// networkManagerEffectiveSecurityAdminRules. It contains a list of groups and a skiptoken to get the next
// set of results.
type ManagerEffectiveSecurityAdminRulesListResult struct {
	autorest.Response `json:"-"`
	// Value - Gets a page of NetworkManagerEffectiveSecurityAdminRules
	Value *[]BasicEffectiveBaseSecurityAdminRule `json:"value,omitempty"`
	// SkipToken - When present, the value can be passed to a subsequent query call (together with the same query and scopes used in the current request) to retrieve the next page of data.
	SkipToken *string `json:"skipToken,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for ManagerEffectiveSecurityAdminRulesListResult struct.
func (mesarlr *ManagerEffectiveSecurityAdminRulesListResult) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "value":
			if v != nil {
				value, err := unmarshalBasicEffectiveBaseSecurityAdminRuleArray(*v)
				if err != nil {
					return err
				}
				mesarlr.Value = &value
			}
		case "skipToken":
			if v != nil {
				var skipToken string
				err = json.Unmarshal(*v, &skipToken)
				if err != nil {
					return err
				}
				mesarlr.SkipToken = &skipToken
			}
		}
	}

	return nil
}

// ManagerListResult result of the request to list NetworkManager. It contains a list of network managers
// and a URL link to get the next set of results.
type ManagerListResult struct {
	autorest.Response `json:"-"`
	// Value - Gets a page of NetworkManager
	Value *[]Manager `json:"value,omitempty"`
	// NextLink - Gets the URL to get the next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// ManagerListResultIterator provides access to a complete listing of Manager values.
type ManagerListResultIterator struct {
	i    int
	page ManagerListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ManagerListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ManagerListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ManagerListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ManagerListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ManagerListResultIterator) Response() ManagerListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ManagerListResultIterator) Value() Manager {
	if !iter.page.NotDone() {
		return Manager{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ManagerListResultIterator type.
func NewManagerListResultIterator(page ManagerListResultPage) ManagerListResultIterator {
	return ManagerListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (mlr ManagerListResult) IsEmpty() bool {
	return mlr.Value == nil || len(*mlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (mlr ManagerListResult) hasNextLink() bool {
	return mlr.NextLink != nil && len(*mlr.NextLink) != 0
}

// managerListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (mlr ManagerListResult) managerListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !mlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(mlr.NextLink)))
}

// ManagerListResultPage contains a page of Manager values.
type ManagerListResultPage struct {
	fn  func(context.Context, ManagerListResult) (ManagerListResult, error)
	mlr ManagerListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ManagerListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ManagerListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.mlr)
		if err != nil {
			return err
		}
		page.mlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ManagerListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ManagerListResultPage) NotDone() bool {
	return !page.mlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ManagerListResultPage) Response() ManagerListResult {
	return page.mlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ManagerListResultPage) Values() []Manager {
	if page.mlr.IsEmpty() {
		return nil
	}
	return *page.mlr.Value
}

// Creates a new instance of the ManagerListResultPage type.
func NewManagerListResultPage(cur ManagerListResult, getNextPage func(context.Context, ManagerListResult) (ManagerListResult, error)) ManagerListResultPage {
	return ManagerListResultPage{
		fn:  getNextPage,
		mlr: cur,
	}
}

// ManagerProperties properties of Managed Network
type ManagerProperties struct {
	// Description - A description of the network manager.
	Description *string `json:"description,omitempty"`
	// NetworkManagerScopes - Scope of Network Manager.
	NetworkManagerScopes *ManagerPropertiesNetworkManagerScopes `json:"networkManagerScopes,omitempty"`
	// NetworkManagerScopeAccesses - Scope Access.
	NetworkManagerScopeAccesses *[]ConfigurationType `json:"networkManagerScopeAccesses,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the network manager resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for ManagerProperties.
func (mp ManagerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if mp.Description != nil {
		objectMap["description"] = mp.Description
	}
	if mp.NetworkManagerScopes != nil {
		objectMap["networkManagerScopes"] = mp.NetworkManagerScopes
	}
	if mp.NetworkManagerScopeAccesses != nil {
		objectMap["networkManagerScopeAccesses"] = mp.NetworkManagerScopeAccesses
	}
	return json.Marshal(objectMap)
}

// ManagerPropertiesNetworkManagerScopes scope of Network Manager.
type ManagerPropertiesNetworkManagerScopes struct {
	// ManagementGroups - List of management groups.
	ManagementGroups *[]string `json:"managementGroups,omitempty"`
	// Subscriptions - List of subscriptions.
	Subscriptions *[]string `json:"subscriptions,omitempty"`
	// CrossTenantScopes - READ-ONLY; List of cross tenant scopes.
	CrossTenantScopes *[]CrossTenantScopes `json:"crossTenantScopes,omitempty"`
}

// MarshalJSON is the custom marshaler for ManagerPropertiesNetworkManagerScopes.
func (mpMs ManagerPropertiesNetworkManagerScopes) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if mpMs.ManagementGroups != nil {
		objectMap["managementGroups"] = mpMs.ManagementGroups
	}
	if mpMs.Subscriptions != nil {
		objectMap["subscriptions"] = mpMs.Subscriptions
	}
	return json.Marshal(objectMap)
}

// ManagersDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ManagersDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ManagersClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ManagersDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ManagersDeleteFuture.Result.
func (future *ManagersDeleteFuture) result(client ManagersClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ManagersDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ManagersDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ManagerSecurityGroupItem network manager security group item.
type ManagerSecurityGroupItem struct {
	// NetworkGroupID - Network manager group Id.
	NetworkGroupID *string `json:"networkGroupId,omitempty"`
}

// PatchObject object for patch operations.
type PatchObject struct {
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for PatchObject.
func (po PatchObject) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if po.Tags != nil {
		objectMap["tags"] = po.Tags
	}
	return json.Marshal(objectMap)
}

// QueryRequestOptions query Request Options
type QueryRequestOptions struct {
	// SkipToken - When present, the value can be passed to a subsequent query call (together with the same query and scopes used in the current request) to retrieve the next page of data.
	SkipToken *string `json:"skipToken,omitempty"`
}

// Resource common resource representation.
type Resource struct {
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if r.ID != nil {
		objectMap["id"] = r.ID
	}
	if r.Location != nil {
		objectMap["location"] = r.Location
	}
	if r.Tags != nil {
		objectMap["tags"] = r.Tags
	}
	return json.Marshal(objectMap)
}

// ScopeConnection the Scope Connections resource
type ScopeConnection struct {
	autorest.Response `json:"-"`
	// ScopeConnectionProperties - The scope connection properties
	*ScopeConnectionProperties `json:"properties,omitempty"`
	// SystemData - READ-ONLY; The system metadata related to this resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
}

// MarshalJSON is the custom marshaler for ScopeConnection.
func (sc ScopeConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sc.ScopeConnectionProperties != nil {
		objectMap["properties"] = sc.ScopeConnectionProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ScopeConnection struct.
func (sc *ScopeConnection) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var scopeConnectionProperties ScopeConnectionProperties
				err = json.Unmarshal(*v, &scopeConnectionProperties)
				if err != nil {
					return err
				}
				sc.ScopeConnectionProperties = &scopeConnectionProperties
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				sc.SystemData = &systemData
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sc.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sc.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sc.Type = &typeVar
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				sc.Etag = &etag
			}
		}
	}

	return nil
}

// ScopeConnectionListResult list of scope connections.
type ScopeConnectionListResult struct {
	autorest.Response `json:"-"`
	// Value - List of scope connections.
	Value *[]ScopeConnection `json:"value,omitempty"`
	// NextLink - Gets the URL to get the next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// ScopeConnectionListResultIterator provides access to a complete listing of ScopeConnection values.
type ScopeConnectionListResultIterator struct {
	i    int
	page ScopeConnectionListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ScopeConnectionListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ScopeConnectionListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ScopeConnectionListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ScopeConnectionListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ScopeConnectionListResultIterator) Response() ScopeConnectionListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ScopeConnectionListResultIterator) Value() ScopeConnection {
	if !iter.page.NotDone() {
		return ScopeConnection{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ScopeConnectionListResultIterator type.
func NewScopeConnectionListResultIterator(page ScopeConnectionListResultPage) ScopeConnectionListResultIterator {
	return ScopeConnectionListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (sclr ScopeConnectionListResult) IsEmpty() bool {
	return sclr.Value == nil || len(*sclr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (sclr ScopeConnectionListResult) hasNextLink() bool {
	return sclr.NextLink != nil && len(*sclr.NextLink) != 0
}

// scopeConnectionListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (sclr ScopeConnectionListResult) scopeConnectionListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !sclr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(sclr.NextLink)))
}

// ScopeConnectionListResultPage contains a page of ScopeConnection values.
type ScopeConnectionListResultPage struct {
	fn   func(context.Context, ScopeConnectionListResult) (ScopeConnectionListResult, error)
	sclr ScopeConnectionListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ScopeConnectionListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ScopeConnectionListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.sclr)
		if err != nil {
			return err
		}
		page.sclr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ScopeConnectionListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ScopeConnectionListResultPage) NotDone() bool {
	return !page.sclr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ScopeConnectionListResultPage) Response() ScopeConnectionListResult {
	return page.sclr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ScopeConnectionListResultPage) Values() []ScopeConnection {
	if page.sclr.IsEmpty() {
		return nil
	}
	return *page.sclr.Value
}

// Creates a new instance of the ScopeConnectionListResultPage type.
func NewScopeConnectionListResultPage(cur ScopeConnectionListResult, getNextPage func(context.Context, ScopeConnectionListResult) (ScopeConnectionListResult, error)) ScopeConnectionListResultPage {
	return ScopeConnectionListResultPage{
		fn:   getNextPage,
		sclr: cur,
	}
}

// ScopeConnectionProperties scope connection.
type ScopeConnectionProperties struct {
	// TenantID - Tenant ID.
	TenantID *string `json:"tenantId,omitempty"`
	// ResourceID - Resource ID.
	ResourceID *string `json:"resourceId,omitempty"`
	// ConnectionState - Connection State. Possible values include: 'ScopeConnectionStateConnected', 'ScopeConnectionStatePending', 'ScopeConnectionStateConflict', 'ScopeConnectionStateRevoked', 'ScopeConnectionStateRejected'
	ConnectionState ScopeConnectionState `json:"connectionState,omitempty"`
	// Description - A description of the scope connection.
	Description *string `json:"description,omitempty"`
}

// SecurityAdminConfiguration defines the security admin configuration
type SecurityAdminConfiguration struct {
	autorest.Response `json:"-"`
	// SecurityAdminConfigurationPropertiesFormat - Indicates the properties for the network manager security admin configuration.
	*SecurityAdminConfigurationPropertiesFormat `json:"properties,omitempty"`
	// SystemData - READ-ONLY; The system metadata related to this resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
}

// MarshalJSON is the custom marshaler for SecurityAdminConfiguration.
func (sac SecurityAdminConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sac.SecurityAdminConfigurationPropertiesFormat != nil {
		objectMap["properties"] = sac.SecurityAdminConfigurationPropertiesFormat
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SecurityAdminConfiguration struct.
func (sac *SecurityAdminConfiguration) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var securityAdminConfigurationPropertiesFormat SecurityAdminConfigurationPropertiesFormat
				err = json.Unmarshal(*v, &securityAdminConfigurationPropertiesFormat)
				if err != nil {
					return err
				}
				sac.SecurityAdminConfigurationPropertiesFormat = &securityAdminConfigurationPropertiesFormat
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				sac.SystemData = &systemData
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sac.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sac.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sac.Type = &typeVar
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				sac.Etag = &etag
			}
		}
	}

	return nil
}

// SecurityAdminConfigurationListResult a list of network manager security admin configurations
type SecurityAdminConfigurationListResult struct {
	autorest.Response `json:"-"`
	// Value - Gets a page of security admin configurations
	Value *[]SecurityAdminConfiguration `json:"value,omitempty"`
	// NextLink - Gets the URL to get the next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// SecurityAdminConfigurationListResultIterator provides access to a complete listing of
// SecurityAdminConfiguration values.
type SecurityAdminConfigurationListResultIterator struct {
	i    int
	page SecurityAdminConfigurationListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *SecurityAdminConfigurationListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SecurityAdminConfigurationListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *SecurityAdminConfigurationListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter SecurityAdminConfigurationListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter SecurityAdminConfigurationListResultIterator) Response() SecurityAdminConfigurationListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter SecurityAdminConfigurationListResultIterator) Value() SecurityAdminConfiguration {
	if !iter.page.NotDone() {
		return SecurityAdminConfiguration{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the SecurityAdminConfigurationListResultIterator type.
func NewSecurityAdminConfigurationListResultIterator(page SecurityAdminConfigurationListResultPage) SecurityAdminConfigurationListResultIterator {
	return SecurityAdminConfigurationListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (saclr SecurityAdminConfigurationListResult) IsEmpty() bool {
	return saclr.Value == nil || len(*saclr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (saclr SecurityAdminConfigurationListResult) hasNextLink() bool {
	return saclr.NextLink != nil && len(*saclr.NextLink) != 0
}

// securityAdminConfigurationListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (saclr SecurityAdminConfigurationListResult) securityAdminConfigurationListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !saclr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(saclr.NextLink)))
}

// SecurityAdminConfigurationListResultPage contains a page of SecurityAdminConfiguration values.
type SecurityAdminConfigurationListResultPage struct {
	fn    func(context.Context, SecurityAdminConfigurationListResult) (SecurityAdminConfigurationListResult, error)
	saclr SecurityAdminConfigurationListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *SecurityAdminConfigurationListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SecurityAdminConfigurationListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.saclr)
		if err != nil {
			return err
		}
		page.saclr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *SecurityAdminConfigurationListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page SecurityAdminConfigurationListResultPage) NotDone() bool {
	return !page.saclr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page SecurityAdminConfigurationListResultPage) Response() SecurityAdminConfigurationListResult {
	return page.saclr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page SecurityAdminConfigurationListResultPage) Values() []SecurityAdminConfiguration {
	if page.saclr.IsEmpty() {
		return nil
	}
	return *page.saclr.Value
}

// Creates a new instance of the SecurityAdminConfigurationListResultPage type.
func NewSecurityAdminConfigurationListResultPage(cur SecurityAdminConfigurationListResult, getNextPage func(context.Context, SecurityAdminConfigurationListResult) (SecurityAdminConfigurationListResult, error)) SecurityAdminConfigurationListResultPage {
	return SecurityAdminConfigurationListResultPage{
		fn:    getNextPage,
		saclr: cur,
	}
}

// SecurityAdminConfigurationPropertiesFormat defines the security admin configuration properties.
type SecurityAdminConfigurationPropertiesFormat struct {
	// Description - A description of the security configuration.
	Description *string `json:"description,omitempty"`
	// ApplyOnNetworkIntentPolicyBasedServices - Enum list of network intent policy based services.
	ApplyOnNetworkIntentPolicyBasedServices *[]IntentPolicyBasedService `json:"applyOnNetworkIntentPolicyBasedServices,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for SecurityAdminConfigurationPropertiesFormat.
func (sacpf SecurityAdminConfigurationPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sacpf.Description != nil {
		objectMap["description"] = sacpf.Description
	}
	if sacpf.ApplyOnNetworkIntentPolicyBasedServices != nil {
		objectMap["applyOnNetworkIntentPolicyBasedServices"] = sacpf.ApplyOnNetworkIntentPolicyBasedServices
	}
	return json.Marshal(objectMap)
}

// SecurityAdminConfigurationsDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type SecurityAdminConfigurationsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SecurityAdminConfigurationsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SecurityAdminConfigurationsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SecurityAdminConfigurationsDeleteFuture.Result.
func (future *SecurityAdminConfigurationsDeleteFuture) result(client SecurityAdminConfigurationsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.SecurityAdminConfigurationsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.SecurityAdminConfigurationsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// StaticMember staticMember Item.
type StaticMember struct {
	autorest.Response `json:"-"`
	// StaticMemberProperties - The Static Member properties
	*StaticMemberProperties `json:"properties,omitempty"`
	// SystemData - READ-ONLY; The system metadata related to this resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
}

// MarshalJSON is the custom marshaler for StaticMember.
func (sm StaticMember) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sm.StaticMemberProperties != nil {
		objectMap["properties"] = sm.StaticMemberProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for StaticMember struct.
func (sm *StaticMember) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var staticMemberProperties StaticMemberProperties
				err = json.Unmarshal(*v, &staticMemberProperties)
				if err != nil {
					return err
				}
				sm.StaticMemberProperties = &staticMemberProperties
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				sm.SystemData = &systemData
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sm.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sm.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sm.Type = &typeVar
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				sm.Etag = &etag
			}
		}
	}

	return nil
}

// StaticMemberListResult result of the request to list StaticMember. It contains a list of groups and a
// URL link to get the next set of results.
type StaticMemberListResult struct {
	autorest.Response `json:"-"`
	// Value - Gets a page of StaticMember
	Value *[]StaticMember `json:"value,omitempty"`
	// NextLink - Gets the URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// StaticMemberListResultIterator provides access to a complete listing of StaticMember values.
type StaticMemberListResultIterator struct {
	i    int
	page StaticMemberListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *StaticMemberListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/StaticMemberListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *StaticMemberListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter StaticMemberListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter StaticMemberListResultIterator) Response() StaticMemberListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter StaticMemberListResultIterator) Value() StaticMember {
	if !iter.page.NotDone() {
		return StaticMember{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the StaticMemberListResultIterator type.
func NewStaticMemberListResultIterator(page StaticMemberListResultPage) StaticMemberListResultIterator {
	return StaticMemberListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (smlr StaticMemberListResult) IsEmpty() bool {
	return smlr.Value == nil || len(*smlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (smlr StaticMemberListResult) hasNextLink() bool {
	return smlr.NextLink != nil && len(*smlr.NextLink) != 0
}

// staticMemberListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (smlr StaticMemberListResult) staticMemberListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !smlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(smlr.NextLink)))
}

// StaticMemberListResultPage contains a page of StaticMember values.
type StaticMemberListResultPage struct {
	fn   func(context.Context, StaticMemberListResult) (StaticMemberListResult, error)
	smlr StaticMemberListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *StaticMemberListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/StaticMemberListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.smlr)
		if err != nil {
			return err
		}
		page.smlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *StaticMemberListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page StaticMemberListResultPage) NotDone() bool {
	return !page.smlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page StaticMemberListResultPage) Response() StaticMemberListResult {
	return page.smlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page StaticMemberListResultPage) Values() []StaticMember {
	if page.smlr.IsEmpty() {
		return nil
	}
	return *page.smlr.Value
}

// Creates a new instance of the StaticMemberListResultPage type.
func NewStaticMemberListResultPage(cur StaticMemberListResult, getNextPage func(context.Context, StaticMemberListResult) (StaticMemberListResult, error)) StaticMemberListResultPage {
	return StaticMemberListResultPage{
		fn:   getNextPage,
		smlr: cur,
	}
}

// StaticMemberProperties properties of static member.
type StaticMemberProperties struct {
	// ResourceID - Resource Id.
	ResourceID *string `json:"resourceId,omitempty"`
	// Region - READ-ONLY; Resource region.
	Region *string `json:"region,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the scope assignment resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for StaticMemberProperties.
func (smp StaticMemberProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if smp.ResourceID != nil {
		objectMap["resourceId"] = smp.ResourceID
	}
	return json.Marshal(objectMap)
}

// SystemData metadata pertaining to creation and last modification of the resource.
type SystemData struct {
	// CreatedBy - The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`
	// CreatedByType - The type of identity that created the resource. Possible values include: 'CreatedByTypeUser', 'CreatedByTypeApplication', 'CreatedByTypeManagedIdentity', 'CreatedByTypeKey'
	CreatedByType CreatedByType `json:"createdByType,omitempty"`
	// CreatedAt - The timestamp of resource creation (UTC).
	CreatedAt *date.Time `json:"createdAt,omitempty"`
	// LastModifiedBy - The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`
	// LastModifiedByType - The type of identity that last modified the resource. Possible values include: 'CreatedByTypeUser', 'CreatedByTypeApplication', 'CreatedByTypeManagedIdentity', 'CreatedByTypeKey'
	LastModifiedByType CreatedByType `json:"lastModifiedByType,omitempty"`
	// LastModifiedAt - The type of identity that last modified the resource.
	LastModifiedAt *date.Time `json:"lastModifiedAt,omitempty"`
}
